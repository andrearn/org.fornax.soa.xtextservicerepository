<?xml version='1.0' ?><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
	<title>DSL Reference</title>
	<chapter id="GeneralRules">
		<title>General syntax rules</title>
		<section id="qualifiedNameRule">
			<title>Qualified names</title>
			Asset names can be fully qualified. A <code>QualifiedName</code> is defined as:
			<programlisting language="base-dsl" format="2">
		ID(.ID)*</programlisting>
			<example>
				<programlisting language="base-dsl" format="2">
		my.qualified.Name
</programlisting>
			</example>
		</section>
		
		<section id="keywordEscapeRule">
			<title>Keyword escapes</title>
			If a name is already a keyword it can be escaped with the character <code>^</code> as usual in Xtext
			based languages.
		</section>
		
		<section id="versionDeclRule">
			<title>Version declarations</title>
			<para>Versioned assets declare their version with the following statement:</para>
			<programlisting language="base-dsl" format="2">
		version INT('.'INT)*
</programlisting>
			<example>
				<programlisting language="base-dsl" format="2">
		version 1.3.1
</programlisting>
			</example>
			<para>The first number is the major version number. Two elements with the same name and major version
			number are considered compatible.</para>
		</section>
		
		<section id="lifecycleDeclRule">
			<title>Lifecycle state declarations</title>
			<para>Elements under the SOA governance lifecycle declare their current state with the following statement:</para>
			<programlisting language="base-dsl" format="2">
		lifecycle-state &lt;LifecycleState&gt;
</programlisting>
			<example>
				<programlisting language="base-dsl" format="2">
		lifecycle-state productive
</programlisting>
			</example>
			<para>Possible lifecycle states are <code>proposed</code>, <code>defined</code>, <code>development</code>,
			<code>test</code>, <code>productive</code>, <code>deprecated</code> and <code>retired</code>. Currently the
			lifecycle state model is static which will be replaced with dynamic model that allows to define allowed state models
			in the SOA profile model.</para>
		</section>
		
		<section id="govApprovalDeclRule">
			<title>Governance approval declarations</title>
			<para>Assets under the SOA governance declare their current approval state with the following section:</para>
			<programlisting language="base-dsl" format="2">
		governance-approval {
			&lt;yes&gt; | &lt;no&gt;
			(decision-on DATESTRING)?
			(decision-by STRING)? 
		}
</programlisting>
			<example>
				<programlisting language="base-dsl" format="2">
		governance-approval {
			yes
			decision-on "01.03.2011"
			decision-by "Max Miller" 
		}
</programlisting>
			</example>
			<para>In the example the asset has been approved on March 1st, 2011 by Max Miller.</para>
		</section>
	</chapter>
	
	
	<chapter id="BusinessDsl">
		<title>Business DSL</title>
		<section id="bizDslLangIntro">
			<title>Introduction</title>
			<para>The Business DSL defines and business capabilties and business functions as well as organizational structures
			that implements the business function. Business capabilities can be mapped to services, service operations or 
			features of a solution. E.g. a service may declare that it realizes a certain capability. Capabilities can be grouped 
			into <code>capability-group</code>s and organized into <code>domain</code>s. It is also possible to define variants
			of a capability.</para>
			<example>
				<programlisting id="bizDslExample" language="business-dsl" format="1">
	domain company.shop {
		
		capability-group Invoicing {
			description "Creating and managing invoices"
			
				
			capability BillRun {
				version 1.0
				short-description "Start the monthly billrun"
				automation-level automated
				business-value "critical"
			}
			
			capability InvoiceCreation {
				version 1.0
				short-description "Create an invoice document for the customer "
				automation-level automated
				business-value "medium"
				inputs {
					input "order"
					input "customer"
					input "customer address"
				}
				outcomes {
					outcome "Invoice document created and archived"
					outcome "Invoice document sent by email and postal mail to the customer"
				}
			}
		}	
		
	}
	</programlisting>
			</example>
			<para>The example defines a capability group <code>Invoicing</code> in the domain <code>company.shop</code>. 
			The capability group contains the fully automated capabilities <code>Billrun</code> and <code>InvoiceCreation</code>.
			The latter one defines required inputs and expected results.</para> 
			<para>Business capability models can be created by creating a new <code>Business DSL file</code>. A wizard is available for that.</para>
		</section>
	</chapter>
	<chapter id="ServiceDSL">
		<title>Service DSL</title>
		<section id="ServiceDSLIntro">
			<title>Language overview</title>
		</section>
		<section id = "ServiceDslFile">
			<title>Service DSL file structure</title>
			<para>A Service DSL file defines namespace, business objects, services and exception. It has the following basic structure:
					<programlisting id="servicedslstructure" language="service-dsl" format="1">
	org-namespace &lt;QualifiedName&gt; shortname "&lt;String&gt;" {
						
		domain-namespace &lt;QualifiedName&gt; shortname "&lt;String&gt;" {
			metadata {
			}
			
			&lt; business objects and enums &gt;
			businessObject AbstractProduct {
				metadata {
					version &lt; version.number&gt;
					lifecycle-state &lt;a governance lifecycle state&gt;
					governance-approval {
						...
					}
				}
				&lt;... attributes and weak-references ...&gt;
			}
			
			
			&lt;services ...&gt;			    
			public service CustomerEntityService {
				metadata {
					version &lt; version.number&gt;
					lifecycle-state &lt;a governance lifecycle state&gt;
					governance-approval {
						...
					}
					category entity
					statefulness &lt; idempodent | stateless | stateful &gt;
					persistence &lt; read | write | read/write &gt;
				}
				
				// operations go here:
				&lt; message exchange pattern: sync | async ...&gt; &lt;operationName&gt; (&lt; (optional) parameters&gt; ) 
					returns &lt;(optional) return paramters&gt;
					throws &lt;exceptions, ...&gt;
				{
					requires &lt; other version constrained service dependency&gt;
				}
			}
			
			&lt; exceptions ... &gt;
			exception &lt;ExceptionName&gt; {
				metadata {
					version &lt; version.number&gt;
					lifecycle-state &lt;a governance lifecycle state&gt;
					governance-approval {
						...
					}
				}
				&lt; exception attributes as in business objects&gt;
			}
		}
	}
</programlisting>				
			</para>
		</section>
		
		<section id = "Namespaces">
			<title>Namespaces</title>
			
			<section id="langOrgNamespace">
				<title>Organization Namespace</title>
				Organization Namespaces are toplevel namespaces like <code>com.example</code>. They reflect
				a company, organization or top level unit of a company. Organization Namespaces are
				used as host part in namespace URIs in reversed order, e.g. <code>http://example.com/</code>
				Organization Namespace should declare a short name which might be used as namespace prefix or
				part of a file name.
			</section>
			
			<section id="langDomainNamespace">
				<title>Domain Namespace</title>
				A Domain Namespace contains a canonical datamodel as well as related public services for a certain 
				logical subdomain. Usually a service DSL file declares a single Domain Namespace and no Domain Namespaces
				are nested in that file within the declared Domain Namespace. Instead subnamespaces will be declared in
				separate file having their namespace name prefixed with with the names of all their parnet Domain
				Namespaces. Hence parent-child relationships of Domain Namespaces are built by apply this 
				naming convention. Dots are used as separators.
				<example>
					<para>
					Be <code>product</code> the top level of all subnamespace related to customers. Then 
					<code>customer.contract</code> would declare the subnamespace <code>contract</code> as subnamespace
					of <code>customer</code>. If <code>org.example</code> would be the top level Organization Namespace 
					containing these Domain Namespaces, the full qualified name would be: 
					<code>org.example.customer.contract</code>. The resulting namespace URI woud look like: <code>http://example.org/customer/contract</code>
					</para>
					<para>
					The resp. declarations with Service DSL would look like:</para>
					<programlisting id="topleveldomains" language="service-dsl" format="1">
	org-namespace com.example shortname "ex" {
						
		domain-namespace customer shortname "cust" {
			metadata {
			}
						    
		}
	}
					</programlisting>
					<para>And it's subdomain:</para>
					<programlisting id = "domainNamespaceListing" language="service-dsl" format="2">
	org-namespace com.example shortname "ex" {
						
		domain-namespace customer.contract shortname "ct" {
			metadata {
			}
					    
		}
	}
					</programlisting>
				</example>
			</section>
			
			<section id="langInternalNamespace">
				<title>Internal Namespace</title>
				<para> An internal namespace contains <xref linkend="PrivateService" xreflabel="private services" >private services</xref> 
				and non canonical datamodel, i.e. internal parts of the infrastructure the may change frequently. 
				Datatypes declared in an internal namespace are being considered noncanonical.  
				Services defined in an internal namespace should be marked <emphasis>private</emphasis>. An internal
				namespace is declared like this:</para>
				<example>
					<programlisting id = "internalNamespaceListing" language="service-dsl" format="2">
	org-namespace com.example shortname "ex" {
						
		internal-namespace customer.contract.internal.backend shortname "ctback" {
			metadata {
			}
						    
		}
	}
					</programlisting>
				</example>
			</section>
		</section>
		<section id="DataTypes">
			<title>Types</title>
			<section id="langBOs">
				<title>BusinessObjects</title>
				BusinessObject are user defined complex datatypes capturing business data. BusinessObject are versioned and have a lifecycle state. 
				The actual data are represented by one or more properties, that have name and a datatype.
				
				<example>
					<programlisting language="service-dsl" format="2">
		businessObject AbstractProduct {
			metadata {
				version 1.0
				lifecycle-state test
				governance-approval {
					yes
					approval-date "20.04.2011"
					approved-by "Anna Jacobson"
				}
			}
			business-key productId : string
			name : string
			price : AbstractPrice majorVersion 1
			category : string
			optional vendor : string
		}
					</programlisting>
				</example>
				
				<section id = "BOMetadata">
					<title>Business object meta data</title>
					<table frame='all' id="boMetaData">
						<title>Properties</title>
						<tgroup cols='4' align='left' colsep='1' rowsep='1'>
							<colspec colname='c1'/>
							<colspec colname='c2'/>
							<colspec colname='c3'/>
							<colspec colname='c4'/>
							<thead>
								<row>
									<entry>Keyword</entry>
									<entry>Valid values</entry>
									<entry>Example</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										version
									</entry>
									<entry>
										INT('.'INT)*
									</entry>
									<entry>
<programlisting language="service-dsl" format="2">version 1.2.1</programlisting>
									</entry>
									<entry>
										The business object version.
									</entry>
								</row>
								<row>
									<entry>
										replaces
									</entry>
									<entry>
										Reference to old business object
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">replaces OldBusinessObject majorVersion 1</programlisting>
									</entry>
									<entry>
										Used to rename business objects or move them to another namespace. The reference to the previous business object is
										given here.
									</entry>
								</row>
								<row>
									<entry>
										lifecycle-state
									</entry>
									<entry>
										proposed | defined | 
										development | test | 
										productive | deprecated | 
										retired
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">lifecycle-state defined</programlisting>
									</entry>
									<entry>
										The lifecycle state of the business object with regard to SOA governance.
									</entry>
								</row>
								<row>
									<entry>
										governance-approval
									</entry>
									<entry>
										see definition of governance approval
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">governance-approval {
	yes
	decision-on "01.02.2011"
	decision-by "John Miller"
}</programlisting>
									</entry>
									<entry>
										The state of the governance decision on the business object.
									</entry>
								</row>
								<row>
									<entry>
										retirement-on
									</entry>
									<entry>
										STRING (Date)
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">retirement-on "01.06.2014"</programlisting>
									</entry>
									<entry>
										The (planned) date of retirement of the business object.
									</entry>
								</row>
								<row>
									<entry>
										provided-definition-URL
									</entry>
									<entry>
										STRING
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">provided-definition-URL "http://somehost:8080/some.xsd"</programlisting>
									</entry>
									<entry>
										Only for business objects defined in internal namespaces. The location where the already existing definition of the business object can be found.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</section>
				
				<section id="boProperties">
					<title>Properties</title>
					<para>Properties may be of one of the following types:</para>
					<itemizedlist>
						<listitem>
						Attributes - Attributes are the basic kind of property. The referenced type is being fully resolved, i.e. an 
						instance being transferred contains all properties of the referenced type. 
						</listitem>
						<listitem>
						Weak references - Contrary to an attribute a weak reference does not resolve to the properties of a referenced type. 
						Instead the businesskey of the referenced type is being used. Weak references are prefixed by the keyword "weak-ref"</listitem>
					</itemizedlist>
					
					<section id="langCommonBOPropFeatures">
						<title>Common features of Properties</title>
						<section>
							<title>Property name and type</title>
							<para>Each property has a name and a type. The name and the type are separated by <code>:</code>. Types may be
							BusinessObjects, Enumerations or DataTypes, i.e. primitive types defined in the SOAProfile. As BusinessObjects and 
							Enumerations are versioned, the type reference of the attribute must declare a version constraint.</para>
							<example>
								<programlisting id="simpleTypeAttribute" language="service-dsl" format="2">
	firstname : string
								</programlisting>
								<programlisting id="boTypeAttribute" language="service-dsl" format="2">
	contract : Contract majorVersion 1
								</programlisting>
							</example> 
						</section>
						<section id="langPropCardinality">
							<title>Cardinality</title>
							Properties may be marked optional by using the keyword <code>optional</code> in front of the property name.
							<example>
								<programlisting id="optionalAttribute" language="service-dsl" format="2">
	optional firstname : string
								</programlisting>
								firstname may be left empty / null 
							</example>
							Properties may also have a collection type:
							<example>
								<programlisting id="listAttribute" language="service-dsl" format="2">
	contracts : Contract [] majorVersion 1
								</programlisting>
								The BusinessObject has a collection of at least one Contract in major version 1.
							</example>
						</section>
					</section>
				</section> 
			</section>
			<section id="langEnum">
				<title>Enumerations</title>
				<section id = "EnumMetadata">
					<title>Enumeration meta data</title>
					<table frame='all' id="boMetaData">
						<title>Properties</title>
						<tgroup cols='4' align='left' colsep='1' rowsep='1'>
							<colspec colname='c1'/>
							<colspec colname='c2'/>
							<colspec colname='c3'/>
							<colspec colname='c4'/>
							<thead>
								<row>
									<entry>Keyword</entry>
									<entry>Valid values</entry>
									<entry>Example</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										version
									</entry>
									<entry>
										INT('.'INT)*
									</entry>
									<entry>
<programlisting language="service-dsl" format="2">version 1.2.1</programlisting>
									</entry>
									<entry>
										The enumeration version.
									</entry>
								</row>
								<row>
									<entry>
										replaces
									</entry>
									<entry>
										Reference to old enumeration
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">replaces OldEnumeration majorVersion 1</programlisting>
									</entry>
									<entry>
										Used to rename enumerations or move them to another namespace. The reference to the previous enumeration is
										given here.
									</entry>
								</row>
								<row>
									<entry>
										lifecycle-state
									</entry>
									<entry>
										proposed | defined | development | test | productive | deprecated | retired
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">lifecycle-state defined</programlisting>
									</entry>
									<entry>
										The lifecycle state of the enumeration with regard to SOA governance.
									</entry>
								</row>
								<row>
									<entry>
										governance-approval
									</entry>
									<entry>
										see definition of governance approval
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">governance-approval {
	yes
	decision-on "01.02.2011"
	decision-by "John Miller"
}</programlisting>
									</entry>
									<entry>
										The state of the governance decision on the enumeration.
									</entry>
								</row>
								<row>
									<entry>
										retirement-on
									</entry>
									<entry>
										STRING (Date)
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">retirement-on "01.06.2014"</programlisting>
									</entry>
									<entry>
										The (planned) date of retirement of the enumeration.
									</entry>
								</row>
								<row>
									<entry>
										provided-definition-URL
									</entry>
									<entry>
										STRING
									</entry>
									<entry>
										<programlisting language="service-dsl" format="2">provided-definition-URL "http://somehost:8080/some.xsd"</programlisting>
									</entry>
									<entry>
										Only for enumerations defined in internal namespaces. The location where the already existing definition of the business object can be found.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</section>
			</section>
		</section>
		<section id="Services">
			<title>Services</title>
			<section id="General service properties">
				<title>General service properties</title>
				
				<section>
					<section id="PublicServices">
						<title>Public services</title>
						<para>Public services comprice the official API and should be generally used. Public services
						may depend, i.e. <code>require</code> a private service. Hence, such a public service would 
						wrap the <code>require</code>d private service.</para>
						<para>Public services may only use the canonical datamodel to be reusable.</para>
					</section>
					<section id="DomainServices">
						<title>Domain services</title>
						Domain services are some more restricted in their usage. They can only be called from services defined
						in the same namespace or one of it's subnamespaces. Domain services may only use the canonical datamodel to be reusable.
					</section>
					<section id="PrivateService">
						<title>Private services</title>
						Private service are internal API that should be wrapped by public or domain services. Private services
						can only be called from the wrapping public and domain service. While they can be called from other 
						private services as well, this is regarded bad design and should be refactored to call their wrapping public services. 
					</section>
				</section>
				<section>
					Every service has a name, version, lifecycle state and governance approval state.					
				</section>
			</section>
			<section id="ServiceSyntax">
				<title>Defining services</title>
				A service is defined in a domain namespace or internal namespace like this:
				<example>
				<programlisting id="optionalAttribute" language="service-dsl" format="2">
	/*
		The CustomerEntityService loads, stores and find Customer instances
	*/
	public service CustomerEntityService {
		metadata {
			version 1.0
			lifecycle-state proposed
			governance-approval {
				yes
				approval-date "20.04.2011"
				approved-by "Anna Jacobson"
			}
			category entity
			statefulness stateful
			persistence read/write
		}
		
		// operations go here:
		sync getCustomerByName (optional firstName : string, lastname : string) 
			returns optional customers : Customer [] majorVersion 1
			throws CustomerNotFoundException 
		{
			requires SomeBackendService majorVersion 1
		}
	}
				</programlisting>
				</example>
			</section>
			<section id = "ServiceMetadata">
				<title>Service meta data</title>
				<table frame='all' id="serviceMetaData">
					<title>Properties</title>
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Valid values</entry>
								<entry>Example</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>
									version
								</entry>
								<entry>
									INT('.'INT)*
								</entry>
								<entry>
<programlisting language="service-dsl" format="2">version 1.0.1</programlisting>
								</entry>
								<entry>
									The service version.
								</entry>
							</row>
							<row>
								<entry>
									lifecycle-state
								</entry>
								<entry>
									proposed | defined | development | test | productive | deprecated | retired
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">lifecycle-state defined</programlisting>
								</entry>
								<entry>
									The lifecycle state of the service with regard to SOA governance.
								</entry>
							</row>
							<row>
								<entry>
									governance-approval
								</entry>
								<entry>
									see definition of governance approval
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">governance-approval {
	yes
	decision-on "01.02.2011"
	decision-by "John Miller"
}</programlisting>
								</entry>
								<entry>
									The state of the governance decision on the service.
								</entry>
							</row>
							<row>
								<entry>
									category
								</entry>
								<entry>
									process | activity | entity | rule | utility
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">category activity</programlisting>
								</entry>
								<entry>
									The service category.
								</entry>
							</row>
							<row>
								<entry>
									statefulness
								</entry>
								<entry>
									idempotend | stateless | stateful
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">statefulness stateless</programlisting>
								</entry>
								<entry>
									Whether the service can be repeatedly called with the same result (idempotend),
									is stateless or stateful.
								</entry>
							</row>
							<row>
								<entry>
									persistence
								</entry>
								<entry>
									read | write | read/write | none
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">persistence read/write</programlisting>
								</entry>
								<entry>
									Whether data treaded by the service are persistent and read and/or written to a persistent store.
								</entry>
							</row>
							<row>
								<entry>
									service-owner
								</entry>
								<entry>
									STRING
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">service-owner "Anna Morris "</programlisting>
								</entry>
								<entry>
									Who is responsible for the service?
								</entry>
							</row>
							<row>
								<entry>
									realizes-capabilty
								</entry>
								<entry>
									((Qualified)?CapabilityName VersionConstraint)+
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">realizes-capabilty InvoiceCustomer fixedVersion 1 InvoiceMail fixedVersion 2</programlisting>
								</entry>
								<entry>
									Reference to one or more business capabilities that are fully realized by the service.
								</entry>
							</row>
							<row>
								<entry>
									supports-capabilty
								</entry>
								<entry>
									((Qualified)?CapabilityName VersionConstraint)+
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">supports-capability InvoiceCustomer fixedVersion 1 InvoiceMail fixedVersion 2</programlisting>
								</entry>
								<entry>
									Reference to one or more business capabilities that are supported, but not fully realized by the service.
								</entry>
							</row>
							<row>
								<entry>
									provided-Contract-URL
								</entry>
								<entry>
									STRING
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">provided-Contract-URL "http://somehost:someport/some.wsdl"</programlisting>
								</entry>
								<entry>
									Only for private services defined in internal namespaces. The location where the already existing contract of the service can be found.
								</entry>
							</row>
							<row>
								<entry>
									sourceURL
								</entry>
								<entry>
									STRING
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">sourceURL "svn://somehost/somelocation"</programlisting>
								</entry>
								<entry>
									Where the sources can be found.
								</entry>
							</row>
							<row>
								<entry>
									docURL
								</entry>
								<entry>
									STRING
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">docURL "svn://somehost/somelocation"</programlisting>
								</entry>
								<entry>
									Where the documentation or specification can be found.
								</entry>
							</row>
							<row>
								<entry>
									release-on
								</entry>
								<entry>
									STRING (Date)
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">release-on "01.06.2010"</programlisting>
								</entry>
								<entry>
									The (planned) release date of the service.
								</entry>
							</row>
							<row>
								<entry>
									retirement-on
								</entry>
								<entry>
									STRING (Date)
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">retirement-on "01.06.2014"</programlisting>
								</entry>
								<entry>
									The (planned) date of retirement of the service.
								</entry>
							</row>
							<row>
								<entry>
									replaces
								</entry>
								<entry>
									Reference to old service
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">replaces OldServiceName majorVersion 1</programlisting>
								</entry>
								<entry>
									Used to rename services or move them to another namespace. The reference to the previous service is
									given here.
								</entry>
							</row>
							<row>
								<entry>
									messageHeader
								</entry>
								<entry>
									Reference to a MessageHeader definition
								</entry>
								<entry>
									<programlisting language="service-dsl" format="2">messageHeader MyHeader majorVersion 1</programlisting>
								</entry>
								<entry>
									An alternative message header to be sent with each message. Usually a 
									default message header has been defined in the profile which is being 
									used when this attribute has not been defined, hence it is an override.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</section>
			<section id = "Operations">
				<title>Operations</title>
			</section>
			<section id = "Parameters">
				<title>Parameters</title>
			</section>
		</section>
		<section>
			<title>Exceptions</title>
		</section>
		
	</chapter>
	<chapter id="ModuleDsl">
		<title>Module DSL</title>
		<section id="langDefModule">
			<title>Defining modules</title>
			<para>Modules aggregate services into a deployable unit. Modules
			have a version and are subject to a lifecycle. The services provided by should be referenced with a fixed version
			in order be to know what exactly the module provides. Hence, a version of a module contains a fixed set of 
			services with exactly defined versions.</para>
			<para>The following example shows, how modules are defined:</para> 
			<example>
				<programlisting language="module-dsl" format="2">
	module com.company.shop.invoicing {
		version 1.4.3
		lifecycle-state test
		assembly-type SCA_EAR
		provides {
			InvoiceProcessService fixedVersion 1.4
			InvoiceActivityService fixedVersion 1.2
			InvoiceNotificationUtilityService fixedVersion 1.1.1
		}
		source-location "git://git.company.com/shop/invoicing"
		revision-tag "Release_1.4.3_RC2"
	}
</programlisting>
			</example>
			<para>The example defines a module with the <code>QualifiedName</code> com.company.shop.invoicing in version 1.4.3 
			that provides three services. The module is available for acceptance test and has been packaged as an EAR containing
			a SCA composite. The source-location and revision tag referring to the source commited to the version control system 
			are optional parameters. The version and lifecycle-state declaration comply to the common syntax rules for versions and 
			lifecycle status declarations being follow the general syntax rules for these used throughout the service repository.</para>
			<para>Modules are declared in <code>Module DSL file</code>s. A wizard is available to create new <code>Module DSL</code> files.</para>
		</section>
	</chapter>
	<chapter id="EnvironmentDsl">
		<title>Environment DSL</title>
		<section id="langDefEnv">
			<title>Defining environments</title>
			<para>The environment defines which servers on are available and where they are hosted. Environments have a unique name and a type
			such as <code>development</code>, <code>test</code> or <code>production</code>. To create a new environment create a 
			new <code>Environment DSL file</code>. A new file wizard is available for that. Then define an environment as i this example:
			</para>
			<example>
				<programlisting language="env-dsl" format="2">
	environment CoreDevelopment of type Development-Environment {
		host as4000 {
			full-qualified-name "as4000.company.com"
		}
		host as4200 {
			full-qualified-name "as4000.company.com"
		}
		host as4350 {
			full-qualified-name "as4350.company.com"
		}
		appserver as4350Tomcat {
			identifier "tomcat.as4350.core.dev"
			host as4350
			baseUrl "http://as4350.company.com:8080"
			connectors {
				HTTP {
					port 8080
					secured-port 8443
				}
				SOAPHTTP {
					port 8080
					secured-port 8443
					context-root "ws"
				}
			}
		}
		
		esb DevESB {
			identifier "esb.as4200.core.dev"
			host localhost
			adminUrl "https://as4200.company.com:9443/ibm/console"
			server-type "websphere"
			server-version "7.5"
			connectors {
				SOAP/HTTP {
					port 9080
					secured-port 9443
					security-protocol SSLv3
					implementation "IBM"
				}
			}
		}
		
		registry reg {
			identifier "simplereg.as4000.core"
			host as4000 
			
			baseUrl "http://registry.company.com"
			
			server-type "Apache"
			server-version "2.2"
			kind HTTP
		}
	}</programlisting>
			</example> 
			<para>In this example three hosts <code>as4000</code> <code>as4200</code> and <code>as4350</code> have set up in the
			development environment named <code>CoreDevelopment</code>. On host <code>as4000</code> an Apache has been installed
			having the identifier <code>simplereg.as4000.core</code> in the Definitive Software Library whithin the Configuration
			Database. On host <code>as4350</code> a tomcat has been installed, that offers HTTP on port 8080 and HTTPS on port 8443
			as outlined in the <code>connectors</code> section. The tomcat also offers a SOAP interface on the same ports, while all
			SOAP service will be available under the context root <code>ws</code>. Finally an ESB has been installed on host 4200, that 
			also offer SOAP on port 9080. The connectors are implicitely referenced from the binding when having the same type as 
			the <code>BindingProtocol</code> defined for a service or module in the binding of them to this environment.</para>
		</section>
	</chapter>
	<chapter id="BindingDsl">
		<title>Binding DSL</title>
		<section id="langDefBind">
			<title>Defining bindings</title>
			<para>The binding creates the link between services / modules and a target environment where they get deployed. Hence they are
			bound to that environment. Consequently a binding would be defined for each environment where the services / modules are deployed. 
			The following example shows how a binding can be defined for a module to a target environment.</para>
			<example>
				<programlisting language="binding-dsl" format="2">
	import CoreDevelopment
	
	bind-module com.company.shop.invoicing fixedVersion 1.4.3 as com.company.shop.invoicing.dev to environment CoreDevelopment {
		provided on DevESB
		default-protocols {
			SOAP {
				style document/literal-wrapped
			}
		}
	}</programlisting>
			</example>
			<para>The module <code>com.company.shop.invoicing</code> in version <code>1.4.3</code> is  bound to the development environment named
			<code>CoreDevelopment</code>. The binding has the name <code>com.company.shop.invoicing.dev</code> to be easily referrable from
			code generators. The binding definition ist pretty simple by stating, that the module will bde deployed to the ESB <code>DevESB</code>
			in the target environment. All services provided by the module will be offered as SOAP services using the document / literal-wrapped style.
			Note that the <code>BindingProtocol</code> <code>SOAP</code> links to the <code>SOAPHTTP connector of the ESB</code></para>
			<para>Bindings are declared in <code>Binding DSL file</code>s. A wizard is available to create new <code>Binding DSL</code> files.</para>
		</section>
	</chapter>
	<chapter id="SolutionDsl">
		<title>Solution DSL</title>
	</chapter>
	<chapter id="ProfileDsl">
		<title>Profile DSL</title>
	</chapter>
</book>