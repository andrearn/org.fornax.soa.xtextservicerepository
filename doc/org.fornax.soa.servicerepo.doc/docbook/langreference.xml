<?xml version='1.0' ?><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
	<title>DSL Reference</title>
	<chapter id="BusinessDsl">
		<title>Business DSL</title>
		<para>The Business DSL defines and business capabilties and business functions as well as organizational structures
		that implements the business function. Business capabilities can be mapped to services, service operations or 
		features of a solution. E.g. a service may declare that it realizes a certain capability. Capabilities can be grouped 
		into <code>capability-group</code>s and organized into <code>domain</code>s. It is also possible to define variants
		of a capability.</para>
	</chapter>
	<chapter id="ServiceDSL">
		<title>Service DSL</title>
		<section id="ServiceDSLIntro">
			<title>Language overview</title>
		</section>
		<section id = "ServiceDslFile">
			<title>Service DSL file structure</title>
			<para>A Service DSL file defines namespace, business objects, services and exception. It has the following basic structure:
					<programlisting id="servicedslstructure" language="service-dsl" format="1">
	org-namespace &lt;QualifiedName&gt; shortname "&lt;String&gt;" {
						
		domain-namespace &lt;QualifiedName&gt; shortname "&lt;String&gt;" {
			metadata {
			}
			
			&lt; business objects and enums &gt;
			businessObject AbstractProduct {
				metadata {
					version &lt; version.number&gt;
					lifecycle-state &lt;a governance lifecycle state&gt;
					governance-approval {
						...
					}
				}
				&lt;... attributes and weak-references ...&gt;
			}
			
			
			&lt;services ...&gt;			    
			public service CustomerEntityService {
				metadata {
					version &lt; version.number&gt;
					lifecycle-state &lt;a governance lifecycle state&gt;
					governance-approval {
						...
					}
					category entity
					statefulness &lt; idempodent | stateless | stateful &gt;
					persistence &lt; read | write | read/write &gt;
				}
				
				// operations go here:
				&lt; message exchange pattern: sync | async ...&gt; &lt;operationName&gt; (&lt; (optional) parameters&gt; ) 
					returns &lt;(optional) return paramters&gt;
					throws &lt;exceptions, ...&gt;
				{
					requires &lt; other version constrained service dependency&gt;
				}
			}
			
			&lt; exceptions ... &gt;
			exception &lt;ExceptionName&gt; {
				metadata {
					version &lt; version.number&gt;
					lifecycle-state &lt;a governance lifecycle state&gt;
					governance-approval {
						...
					}
				}
				&lt; exception attributes as in business objects&gt;
			}
		}
	}
</programlisting>				
			</para>
		</section>
		<section id = "Namespaces">
			<title>Namespaces</title>
			
			<section>
				<title>Organization Namespace</title>
				Organization Namespaces are toplevel namespaces like <code>com.example</code>. They reflect
				a company, organization or top level unit of a company. Organization Namespaces are
				used as host part in namespace URIs in reversed order, e.g. <code>http://example.com/</code>
				Organization Namespace should declare a short name which might be used as namespace prefix or
				part of a file name.
			</section>
			<section>
				<title>Domain Namespace</title>
				A Domain Namespace contains a canonical datamodel as well as related public services for a certain 
				logical subdomain. Usually a service DSL file declares a single Domain Namespace and no Domain Namespaces
				are nested in that file within the declared Domain Namespace. Instead subnamespaces will be declared in
				separate file having their namespace name prefixed with with the names of all their parnet Domain
				Namespaces. Hence parent-child relationships of Domain Namespaces are built by apply this 
				naming convention. Dots are used as separators.
				<example>
					<para>
					Be <code>product</code> the top level of all subnamespace related to customers. Then 
					<code>customer.contract</code> would declare the subnamespace <code>contract</code> as subnamespace
					of <code>customer</code>. If <code>org.example</code> would be the top level Organization Namespace 
					containing these Domain Namespaces, the full qualified name would be: 
					<code>org.example.customer.contract</code>. The resulting namespace URI woud look like: <code>http://example.org/customer/contract</code>
					</para>
					<para>
					The resp. declarations with Service DSL would look like:</para>
					<programlisting id="topleveldomains" language="service-dsl" format="1">
	org-namespace com.example shortname "ex" {
						
		domain-namespace customer shortname "cust" {
			metadata {
			}
						    
		}
	}
					</programlisting>
					<para>And it's subdomain:</para>
					<programlisting id = "domainNamespaceListing" language="service-dsl" format="2">
	org-namespace com.example shortname "ex" {
						
		domain-namespace customer.contract shortname "ct" {
			metadata {
			}
					    
		}
	}
					</programlisting>
				</example>
			</section>
			<section>
				<title>Internal Namespace</title>
				<para> An internal namespace contains <xref linkend="PrivateService" xreflabel="private services" >private services</xref> 
				and non canonical datamodel, i.e. internal parts of the infrastructure the may change frequently. 
				Datatypes declared in an internal namespace are being considered noncanonical.  
				Services defined in an internal namespace should be marked <emphasis>private</emphasis>. An internal
				namespace is declared like this:</para>
				<example>
					<programlisting id = "internalNamespaceListing" language="service-dsl" format="2">
	org-namespace com.example shortname "ex" {
						
		internal-namespace customer.contract.internal.backend shortname "ctback" {
			metadata {
			}
						    
		}
	}
					</programlisting>
				</example>
			</section>
		</section>
		<section id="DataTypes">
			<title>Types</title>
			<section>
				<title>BusinessObjects</title>
				BusinessObject are user defined complex datatypes capturing business data. BusinessObject are versioned and have a lifecycle state. 
				The actual data are represented by one or more properties, that have name and a datatype.
				
				<example>
					<programlisting language="service-dsl" format="2">
		businessObject AbstractProduct {
			metadata {
				version 1.0
				lifecycle-state test
				governance-approval {
					yes
					approval-date "20.04.2011"
					approved-by "Anna Jacobson"
				}
			}
			business-key productId : string
			name : string
			price : AbstractPrice majorVersion 1
			category : string
			optional vendor : string
		}
					</programlisting>
				</example>
				
				<section>
					<title>Business object meta data</title>
				</section>
				
				<section id="boProperties">
					<title>Properties</title>
					<para>Properties may be of one of the following types:</para>
					<itemizedlist>
						<listitem>
						Attributes - Attributes are the basic kind of property. The referenced type is being fully resolved, i.e. an 
						instance being transferred contains all properties of the referenced type. 
						</listitem>
						<listitem>
						Weak references - Contrary to an attribute a weak reference does not resolve to the properties of a referenced type. 
						Instead the businesskey of the referenced type is being used. Weak references are prefixed by the keyword "weak-ref"</listitem>
					</itemizedlist>
					
					<section>
						<title>Common features of Properties</title>
						<section>
							<title>Property name and type</title>
							<para>Each property has a name and a type. The name and the type are separated by <code>:</code>. Types may be
							BusinessObjects, Enumerations or DataTypes, i.e. primitive types defined in the SOAProfile. As BusinessObjects and 
							Enumerations are versioned, the type reference of the attribute must declare a version constraint.</para>
							<example>
								<programlisting id="simpleTypeAttribute" language="service-dsl" format="2">
	firstname : string
								</programlisting>
								<programlisting id="boTypeAttribute" language="service-dsl" format="2">
	contract : Contract majorVersion 1
								</programlisting>
							</example> 
						</section>
						<section>
							<title>Cardinality</title>
							Properties may be marked optional by using the keyword <code>optional</code> in front of the property name.
							<example>
								<programlisting id="optionalAttribute" language="service-dsl" format="2">
	optional firstname : string
								</programlisting>
								firstname may be left empty / null 
							</example>
							Properties may also have a collection type:
							<example>
								<programlisting id="listAttribute" language="service-dsl" format="2">
	contracts : Contract [] majorVersion 1
								</programlisting>
								The BusinessObject has a collection of at least one Contract in major version 1.
							</example>
						</section>
					</section>
				</section> 
			</section>
			<section>
				<title>Enumerations</title>
			</section>
		</section>
		<section id="Services">
			<title>Services</title>
			<section id="General service properties">
				<title>General service properties</title>
				
				<section>
					<section id="PublicServices">
						<title>Public services</title>
						<para>Public services comprice the official API and should be generally used. Public services
						may depend, i.e. <code>require</code> a private service. Hence, such a public service would 
						wrap the <code>require</code>d private service.</para>
						<para>Public services may only use the canonical datamodel to be reusable.</para>
					</section>
					<section id="DomainServices">
						<title>Domain services</title>
						Domain services are some more restricted in their usage. They can only be called from services defined
						in the same namespace or one of it's subnamespaces.
					</section>
					<section id="PrivateService">
						<title>Private services</title>
						Private service are internal API that should be wrapped by public or domain services. Private services
						can only be called from wrapping public and domain services. While they can be called from other 
						private services as well, this is regarded bad design and should be refactered to call their wrapping public services. 
					</section>
				</section>
				<section>
					Every service has a name, version, lifecycle state and governance approval state.					
				</section>
			</section>
			<section id="ServiceSyntax">
				<title>Defining services</title>
				A service is defined in a domain namespace or internal namespace like this:
				<example>
				<programlisting id="optionalAttribute" language="service-dsl" format="2">
	/*
		The CustomerEntityService loads, stores and find Customer instances
	*/
	public service CustomerEntityService {
		metadata {
			version 1.0
			lifecycle-state proposed
			governance-approval {
				yes
				approval-date "20.04.2011"
				approved-by "Anna Jacobson"
			}
			category entity
			statefulness stateful
			persistence read/write
		}
		
		// operations go here:
		sync getCustomerByName (optional firstName : string, lastname : string) 
			returns optional customers : Customer [] majorVersion 1
			throws CustomerNotFoundException 
		{
			requires SomeBackendService majorVersion 1
		}
	}
				</programlisting>
				</example>
			</section>
			<section id = "ServiceMetadata">
				<title>Service meta data</title>
			</section>
			<section id = "Operations">
				<title>Operations</title>
			</section>
			<section id = "Parameters">
				<title>Parameters</title>
			</section>
		</section>
		<section>
			<title>Exceptions</title>
		</section>
		
	</chapter>
	<chapter id="ModuleDsl">
		<title>Module DSL</title>
	</chapter>
	<chapter id="EnvironmentDsl">
		<title>Environment DSL</title>
	</chapter>
	<chapter id="BindingDsl">
		<title>Binding DSL</title>
	</chapter>
	<chapter id="SolutionDsl">
		<title>Solution DSL</title>
	</chapter>
	<chapter id="ProfileDsl">
		<title>Profile DSL</title>
	</chapter>
</book>