/*
Copyright (c) 2010-2011 André Arnold and others.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
    André Arnold 		- initial API and implementation
    Christian Schneider	- reviews
*/
grammar org.fornax.soa.profiledsl.SOAProfileDsl with org.fornax.soa.basedsl.SOABaseDsl

generate sOAProfileDsl "http://www.fornax.org/soa/profiledsl/SOAProfileDsl"

import "http://www.fornax.org/soa/EnvironmentDsl" as  environmentDsl

SOAProfileModel:
	(imports+=Import)*
	(types+=DataType)+
	(profiles += SOAProfile)*
	(roles+=Role)*;

/*
 * Defines architectural constraints that apply. General foundational governance principles, like lifecycle states 
 * are defined as well in the profile. Usually scoped to an organization
 */	
SOAProfile:
	'soa-profile' name=ID '{'
		/* The scope, where the architecture profile applies to */
		'scope' scope = STRING
		/* The asset lifecycle states */
		lifecycle=Lifecycle
		/* The available service categories */
		'service-categories' '{'
			serviceCategory+=ServiceCategory+
		'}'
		/* 
		 * basic message principles, e.g. message headers that have to be set in every service message
		 * if not stated otherwise in the service definition
		 */
		(messaging=Messaging)?
		(designRules=DesignRules)?
		(versioningRule = VersioningRule)
		(orgNamespaces+=OrganizationNamespace)*
		(namespaceRules = NamespaceRules)?
		(scopedBasicTypes+=BasicTypes)*
		(governanceDecisions+=GovernanceDecision)*
		
	'}';

/*
 * Defines an asset lifecycle and it's possible state transitions
 */
Lifecycle:
	'lifecycle' name = ID '{'
		(states+= LifecycleState)+
	'}';

/*
 * Defines an asset lifecycle state
 */
LifecycleState:
	(isInitial?='initial' | isEnd?='end')? 'state' name = ID '{'
		(requiresApproval?='requires-approval')?
		(strictChecks?='strict-checks')?
		('qualifies-for' (qualifiesFor+=EnvironmentType)(',' qualifiesFor+=EnvironmentType)*)?
		('qualifies-for-environment' (qualifiesForEnvironment+=[environmentDsl::Environment])(',' qualifiesForEnvironment+=[environmentDsl::Environment])*)?
		(transitions+=Transition)*
	'}';
	
Transition: '->' targetState = [LifecycleState | QualifiedName] ('by' (roles+=[Role | QualifiedName])(',' roles+=[Role | QualifiedName])*)?;

/*
 * User role, e.g. to authorize asset lifecycle state transition
 */
Role: 
	'role' name=ID;

/* 
 * Defines a service category
 */	
ServiceCategory:
	name = ID 'base-category' baseCategory = ServiceBaseCategory
;

enum ServiceBaseCategory: process | rule | activity | entity | utility | other;

enum EnvironmentType returns environmentDsl::EnvironmentType: Prod = "Production-Environment" | Staging="Staging-Environment" | Test="Test-Environment" | Dev="Development-Environment" | Local="Local-Environment" | Other="Other-Environment";

/* 
 * Defines basic messaging principles, e.g. message headers that have to be set in every service message
 * if not stated otherwise in the service definition
 */
Messaging :
	{Messaging} 'messaging' '{'
		(messageHeaders+=MessageHeader)*
		('default-header' defaultHeader=MessageHeaderRef )?
	'}';

/*
 * General design rules for services and types
 */	
DesignRules:
	{DesignRules} 'design-rules' '{'
		(internalNamespaceRules+=InternalNamespaceRule)*
		(typeDefPolicy=TypeDefPolicy)?
		(serviceDefPolicy=ServiceDefPolicy)?
	'}';

/*
 * Conventions that apply to namespaces, especially their names
 */	
NamespaceRules:
	{NamespaceRules}
	'namespace-rules' '{'
		(noTrailingSlash?='no-trailing-slash-in-namespace-uri')?
		(aliases+=BaseNamespaceAlias)*
	'}';

/*
 * How technical assets with the same name declare a version
 * <ul>
 * 	<li>by using different namespaces, but the same name</li>
 * 	<li>by using different names, but the same namespace</li>
 * </ul>
 */	
VersioningRule: 'versioning-strategy' versioningStrategy = VersioningStrategy;

/*
 * Definies the basic / primitive types
 */	
BasicTypes:
	'basic-types' 'for' scope=ID '{'
		(types+=DataType)+
	'}';
	
BaseNamespaceAlias :
	'shorten' baseNamespaceFragment=QualifiedName 'to' shortenedBaseNamespaceFragment=QualifiedName ;

/*
 * The toplevel namespace of the organization
 */
OrganizationNamespace:
	'org-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		(subNamespaces+=TechnicalNamespace)*
	'}' ;

/*
 * A technical namespace, e.g. used to declare message object types
 */	
TechnicalNamespace: 
	'namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		(noTrailingSlash?='no-trailing-slash-in-namespace-uri')?
		(types+=Type)*
	'}';
 
/*
 * Declares a versioned message header for service messages
 */
MessageHeader:
	'message-headers' name=QualifiedName '{'
		'meta-data' '{'
			version=Version 
			'lifecycle-state' state=[LifecycleState | QualifiedName]
			(governanceDecisions+=GovernanceDecision)*
			/* For which message exchange patterns the header is being used */
			'for' (exchanges+=MEPMessageKind) (',' exchanges+=MEPMessageKind)*
			/* may extension placeholder properties be used */ 
			(extendableProperties?='extendable-properties' )?
			/* may extension placeholder XML schema element attributes be used */ 
			(extendableXMLAttributes?='extendable-XML-attributes' )?
		'}'
		/* The parameters of the message header. The parameters are available as operation parameters. 
		 * Parameters should not be stated again in the service operation definition*/
		(parameters+=Property)+
	'}';
	
enum MEPMessageKind: REQUEST = 'request' | RESPONSE = 'response' | PUBLISH = 'publish';

enum VersioningStrategy: NAMESPACE = 'namespace-based' | NAME = 'name-based';

AbstractProperty : 
	Property | Attribute;	
	
Property:
	(optional?='optional')? name=ID ':' type=TypeRef ;

Attribute:
	(optional?='optional')? 'attr' name=ID ':' type=AttributeDataTypeRef ;

TypeRef:	DataTypeRef | VersionedTypeRef;

VersionedTypeRef:
	type=[VersionedType|QualifiedName] (many?='[]' (set?='as set')? )? versionRef=VersionRef;
	
DataTypeRef: 
	type=[DataType|QualifiedName] (many?='[]' (set?='as set')? )?;
	
AttributeDataTypeRef: 
	type=[DataType|QualifiedName];

EnumRef: 
	type=[Enumeration|QualifiedName] versionRef=VersionRef;

ClassRef: 
	type=[Class|QualifiedName] versionRef=VersionRef;
	
MessageHeaderRef:
	header=[MessageHeader|QualifiedName] versionRef=VersionRef;

Type : DataType | VersionedType;

DataType hidden(WS):
	'datatype' name=ID ('extends' base=[DataType] 'scope' scope=STRING)? ;
	
VersionedType:	Enumeration | Class;

Enumeration:
	'enum' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EnumRef )?
			'lifecycle-state' state=[LifecycleState | QualifiedName]
			(governanceDecisions+=GovernanceDecision)*
		'}'
		(literals+=EnumLiteral )*
	'}';

EnumLiteral: 
	name=ID;
	
Class:
	'class' name=ID ('extends' superClass=ClassRef)? '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EnumRef )?
			'lifecycle-state' state=[LifecycleState | QualifiedName]
			(governanceDecisions+=GovernanceDecision)*
		'}'
		(properties+=AbstractProperty)+
	'}';

/* Design rule that applies to internal namespaces, e.g. naming convention to be checked by validators */
InternalNamespaceRule: 
	'internal-namespace-rule' name=ID '{'
		'internal-qualifier' internalNsQualifierPolicy = InternalNsQualifierPolicy  
		('qualifying-name' qualifyingName = ID )?
		(noTrailingSlash?='no-trailing-slash-in-namespace-uri')?
	'}';
	
enum InternalNsQualifierPolicy:
	MUST_CONTAIN_QUALIFIER = 'must-contain-internal-qualifier' |
	BEFORE_LAST_ID = 'qualifier-before-last-name' |
	USE_IF_DEFINED = 'use-when-defined' |
	NO_QUALIFIER = 'no-qualifier'
 	; 

TypeDefPolicy: 
	{TypeDefPolicy}
	'types' '{'
		(extendableProperties?='extendable-properties' )?
		('extendable-XML-clause' extendableXMLClause = STRING )?
		(extendableXMLAttributes?='extendable-XML-attributes' )?
		('extendable-XML-attribute-clause' extendableXMLAttributeClause = STRING)?
		(extendableSubTypes?='extendable-sub-types')?
		(allowEnums?='allow-enums' )?
		(allowInheritance?='allow-inheritance' )?
		(allowPolymorphism?='allow-polymorphism' )?
	'}';

/*
 * Defines convention to be met by service definitions
 */	
ServiceDefPolicy:
	{ServiceDefPolicy}
	'services' '{'
		'operations' '{'
			(extendableParameters?='extendable-parameters' )?
			(extendableXMLAttributes?='extendable-XML-attributes' )?
			(allowPolymorphism?='allow-polymorphism' )?
		'}'
	'}';