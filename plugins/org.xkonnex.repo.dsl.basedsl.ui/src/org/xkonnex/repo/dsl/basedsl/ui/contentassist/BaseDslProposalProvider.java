/*
* generated by Xtext
*/
package org.xkonnex.repo.dsl.basedsl.ui.contentassist;

import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.ui.search.IXtextEObjectSearch;
import org.xkonnex.repo.dsl.basedsl.resource.VersionedResourceDescriptionStrategy;
import org.xkonnex.repo.dsl.basedsl.ui.contentassist.AbstractBaseDslProposalProvider;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.inject.Inject;
import com.google.common.collect.Lists;
/**
 * see http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on how to customize content assistant
 */
public class BaseDslProposalProvider extends AbstractBaseDslProposalProvider {

	@Inject
	private IXtextEObjectSearch searchEngine;

	public void complete_QualifiedName(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.complete_QualifiedName(model, ruleCall, context, acceptor);
		String proposal = "qualified.name";
		acceptor.accept(createCompletionProposal(proposal , context));
	}

	public void complete_VersionId(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.complete_VersionId(model, ruleCall, context, acceptor);
		String proposal = "0.0.0";
		acceptor.accept(createCompletionProposal(proposal , context));
	}

	public Iterable<String> getCanditateVersions(final String canditateName, final String canditateClassName, final Iterable<String> importedNamespaces, final boolean majorVersionsOnly) {
		Iterable<IEObjectDescription> canditates = findByNameAndEClass(canditateName, canditateClassName, importedNamespaces);
		return extractCanditateVersions (canditates, majorVersionsOnly);
	}

	public Iterable<String> getCanditateVersions(final String canditateName, final List<String> canditateClassName, final Iterable<String> importedNamespaces, final boolean majorVersionsOnly) {
		List<IEObjectDescription> canditates = Lists.newArrayList();
		for (String className : canditateClassName) {
			List<IEObjectDescription> curCanditates = Lists.newArrayList (findByNameAndEClass (canditateName, className, importedNamespaces));
			canditates.addAll (curCanditates);
		}
		return extractCanditateVersions (canditates, majorVersionsOnly);
	}
	
	private Iterable<IEObjectDescription> findByNameAndEClass (final String canditateName, final String canditateClassName, final Iterable<String> importedNamespaces) {
		Iterable<IEObjectDescription> ieObjDesc = searchEngine.findMatches (canditateName + " ", canditateClassName);
		if (!ieObjDesc.iterator().hasNext()) {
			ieObjDesc = Iterables.concat (ieObjDesc, searchEngine.findMatches("*." + canditateName + " ", canditateClassName));
			ieObjDesc = Iterables.filter (ieObjDesc, new Predicate<IEObjectDescription>() {
	
				public boolean apply(IEObjectDescription desc) {
					for (String impName : importedNamespaces) {
						if (desc.getName().toString().equals(impName + "." + canditateName))
							return true;
					}
					return false;
				}
			});
		}
		return ieObjDesc;
	}

	private Iterable<String> extractCanditateVersions (Iterable<IEObjectDescription> canditates, final boolean majorVersionsOnly) {
		Iterable<String> versions = Iterables.transform (canditates, new Function<IEObjectDescription, String> () {
	
			public String apply(IEObjectDescription from) {
				String version = from.getUserData (VersionedResourceDescriptionStrategy.VERSION_KEY);
				if (majorVersionsOnly)
					return version.substring(0, version.indexOf("."));
				return version;
			}
			
		});
		return Sets.newTreeSet (Iterables.filter(versions, Predicates.notNull()));
	}

}
