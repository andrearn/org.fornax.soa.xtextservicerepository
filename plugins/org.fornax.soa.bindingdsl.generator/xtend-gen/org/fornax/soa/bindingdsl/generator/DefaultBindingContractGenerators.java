package org.fornax.soa.bindingdsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.google.inject.name.Named;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.impl.ResourceSetBasedResourceDescriptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.fornax.soa.basedsl.sOABaseDsl.Version;
import org.fornax.soa.basedsl.search.IEObjectLookup;
import org.fornax.soa.basedsl.search.IPredicateSearch;
import org.fornax.soa.binding.query.environment.EnvironmentBindingResolver;
import org.fornax.soa.bindingDsl.Binding;
import org.fornax.soa.bindingDsl.BindingModel;
import org.fornax.soa.bindingDsl.ModuleBinding;
import org.fornax.soa.bindingdsl.generator.ModuleBindingSelector;
import org.fornax.soa.bindingdsl.generator.templates.IArtifactBuilder;
import org.fornax.soa.bindingdsl.generator.templates.xsd.XSDBuilder;
import org.fornax.soa.environmentDsl.Environment;
import org.fornax.soa.moduledsl.generator.VersionedModuleSelector;
import org.fornax.soa.moduledsl.moduleDsl.EndpointQualifierRef;
import org.fornax.soa.moduledsl.moduleDsl.Module;
import org.fornax.soa.moduledsl.moduleDsl.ModuleDslFactory;
import org.fornax.soa.moduledsl.moduleDsl.ModuleModel;
import org.fornax.soa.profiledsl.sOAProfileDsl.SOAProfile;
import org.fornax.soa.semanticsDsl.Qualifier;
import org.fornax.soa.serviceDsl.DomainNamespace;
import org.fornax.soa.serviceDsl.InternalNamespace;
import org.fornax.soa.serviceDsl.OrganizationNamespace;
import org.fornax.soa.serviceDsl.ServiceModel;
import org.fornax.soa.serviceDsl.SubNamespace;

/**
 * Generate technical service and datamodel contract artifacts like WSDLs, XSDs or IDLs for ModuleBindings
 * or DomainBinding filtered by name and selected target environment. For each protocol statet in the Binding,
 * the respective contract artifacts used by services supporting that protocol type are generated. The generation
 * is delegeted to a builder chain, while each protocol is handled by a certain <code>IProtocolContractBuilder</code><br/><br/>
 * 
 * E.g. SOAP contract artifacts are generated by the SOAPProtocolContractBuilder. Generated artifacts include a
 * concrete WSDL defining the SOAP binding and the service endpoint, an abstract WSDL to define the interface structure
 * and XSDs for the parameter types.
 */
@SuppressWarnings("all")
public class DefaultBindingContractGenerators implements IGenerator {
  @Inject
  private IArtifactBuilder bindingBuilder;
  
  @Inject
  private XSDBuilder xsdGen;
  
  @Inject
  @Named(value = "profileName")
  private String profileName;
  
  @Inject
  @Named(value = "moduleBindingNames")
  private List<String> moduleBindingNames;
  
  @Inject
  @Named(value = "modules")
  private List<VersionedModuleSelector> modules;
  
  @Inject
  @Named(value = "moduleBindings")
  private List<ModuleBindingSelector> moduleBindingSelectors;
  
  @Inject
  @Named(value = "namespaces")
  private List<String> namespaces;
  
  @Inject
  @Named(value = "domainNamespaces")
  private List<String> domainNamespaces;
  
  @Inject
  @Named(value = "internalNamespaces")
  private List<String> internalNamespaces;
  
  @Inject
  @Named(value = "noDependencies")
  private Boolean noDependencies;
  
  @Inject
  @Named(value = "includeSubNamespaces")
  private Boolean includeSubNamespaces;
  
  @Inject
  @Named(value = "targetEnvironmentName")
  private String targetEnvironmentName;
  
  @Inject
  private IPredicateSearch searchEngine;
  
  @Inject
  private ResourceSetBasedResourceDescriptions resourceDescriptions;
  
  @Inject
  private IQualifiedNameProvider nameProvider;
  
  @Inject
  private IEObjectLookup eObjectLookup;
  
  @Inject
  private Logger logger;
  
  @Inject
  private EnvironmentBindingResolver _environmentBindingResolver;
  
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    EList<EObject> _contents = resource.getContents();
    EObject contentRoot = IterableExtensions.<EObject>head(_contents);
    ResourceSet resourceSet = resource.getResourceSet();
    this.resourceDescriptions.setContext(resourceSet);
    boolean hasValidParameters = true;
    boolean _or = false;
    boolean _equals = Objects.equal(this.targetEnvironmentName, null);
    if (_equals) {
      _or = true;
    } else {
      boolean _equals_1 = "".equals(this.targetEnvironmentName);
      _or = (_equals || _equals_1);
    }
    if (_or) {
      this.logger.severe("No targetEnvironmentName has been supplied to the Generator. Please provide the name of the environment to generate contracts for.");
      hasValidParameters = false;
    }
    boolean _or_1 = false;
    boolean _equals_2 = Objects.equal(this.profileName, null);
    if (_equals_2) {
      _or_1 = true;
    } else {
      boolean _equals_3 = "".equals(this.profileName);
      _or_1 = (_equals_2 || _equals_3);
    }
    if (_or_1) {
      this.logger.severe("No profileName has been supplied to the Generator. Please provide the name an architecture profile to be applied.");
      hasValidParameters = false;
    }
    SOAProfile profile = this.eObjectLookup.<SOAProfile>getModelElementByName(this.profileName, resource, "SOAProfile");
    boolean _equals_4 = Objects.equal(profile, null);
    if (_equals_4) {
      String _plus = ("No profile found mathing the name " + this.profileName);
      this.logger.severe(_plus);
      hasValidParameters = false;
    }
    if (hasValidParameters) {
      if ((contentRoot instanceof BindingModel)) {
        EList<EObject> _contents_1 = resource.getContents();
        EObject _head = IterableExtensions.<EObject>head(_contents_1);
        BindingModel model = ((BindingModel) _head);
        EList<Binding> _bindings = model.getBindings();
        for (final Binding binding : _bindings) {
          if ((binding instanceof ModuleBinding)) {
            final ModuleBinding modBind = ((ModuleBinding) binding);
            boolean _and = false;
            final Function1<String,Boolean> _function = new Function1<String,Boolean>() {
                public Boolean apply(final String modBindName) {
                  String _name = modBind.getName();
                  boolean _matches = Pattern.matches(modBindName, _name);
                  return Boolean.valueOf(_matches);
                }
              };
            boolean _exists = IterableExtensions.<String>exists(this.moduleBindingNames, _function);
            if (!_exists) {
              _and = false;
            } else {
              Environment _resolveEnvironment = this._environmentBindingResolver.resolveEnvironment(modBind);
              String _name = _resolveEnvironment.getName();
              boolean _matches = Pattern.matches(this.targetEnvironmentName, _name);
              _and = (_exists && _matches);
            }
            if (_and) {
              this.compile(modBind, profile);
            }
            for (final ModuleBindingSelector modBindingSelector : this.moduleBindingSelectors) {
              boolean _matches_1 = modBindingSelector.matches(modBind, this.nameProvider);
              if (_matches_1) {
                this.compile(modBind, profile);
              }
            }
          }
        }
      }
      if ((contentRoot instanceof ModuleModel)) {
        final ModuleModel modModel = ((ModuleModel) contentRoot);
        EList<Module> _modules = modModel.getModules();
        for (final Module module : _modules) {
          final Function1<VersionedModuleSelector,Boolean> _function_1 = new Function1<VersionedModuleSelector,Boolean>() {
              public Boolean apply(final VersionedModuleSelector mod) {
                boolean _matches = mod.matches(module, DefaultBindingContractGenerators.this.nameProvider);
                return Boolean.valueOf(_matches);
              }
            };
          boolean _exists_1 = IterableExtensions.<VersionedModuleSelector>exists(this.modules, _function_1);
          if (_exists_1) {
            final Function1<VersionedModuleSelector,Boolean> _function_2 = new Function1<VersionedModuleSelector,Boolean>() {
                public Boolean apply(final VersionedModuleSelector modSel) {
                  boolean _matches = modSel.matches(module, DefaultBindingContractGenerators.this.nameProvider);
                  return Boolean.valueOf(_matches);
                }
              };
            final VersionedModuleSelector moduleSelector = IterableExtensions.<VersionedModuleSelector>findFirst(this.modules, _function_2);
            this.compile(module, moduleSelector, profile, resource);
          }
        }
      }
      if ((contentRoot instanceof ServiceModel)) {
        final ServiceModel svcModel = ((ServiceModel) contentRoot);
        EList<OrganizationNamespace> _orgNamespaces = svcModel.getOrgNamespaces();
        final Function1<OrganizationNamespace,EList<SubNamespace>> _function_3 = new Function1<OrganizationNamespace,EList<SubNamespace>>() {
            public EList<SubNamespace> apply(final OrganizationNamespace ons) {
              EList<SubNamespace> _subNamespaces = ons.getSubNamespaces();
              return _subNamespaces;
            }
          };
        List<EList<SubNamespace>> _map = ListExtensions.<OrganizationNamespace, EList<SubNamespace>>map(_orgNamespaces, _function_3);
        final Iterable<? extends SubNamespace> subNamespaces = Iterables.<SubNamespace>concat(_map);
        for (final SubNamespace ns : subNamespaces) {
          {
            final Function1<String,Boolean> _function_4 = new Function1<String,Boolean>() {
                public Boolean apply(final String nsName) {
                  QualifiedName _fullyQualifiedName = DefaultBindingContractGenerators.this.nameProvider.getFullyQualifiedName(ns);
                  String _string = _fullyQualifiedName.toString();
                  boolean _matches = Pattern.matches(nsName, _string);
                  return Boolean.valueOf(_matches);
                }
              };
            boolean _exists_2 = IterableExtensions.<String>exists(this.namespaces, _function_4);
            if (_exists_2) {
              this.compile(((SubNamespace) ns), resource);
            }
            boolean _and_1 = false;
            if (!(ns instanceof DomainNamespace)) {
              _and_1 = false;
            } else {
              final Function1<String,Boolean> _function_5 = new Function1<String,Boolean>() {
                  public Boolean apply(final String nsName) {
                    QualifiedName _fullyQualifiedName = DefaultBindingContractGenerators.this.nameProvider.getFullyQualifiedName(ns);
                    String _string = _fullyQualifiedName.toString();
                    boolean _matches = Pattern.matches(nsName, _string);
                    return Boolean.valueOf(_matches);
                  }
                };
              boolean _exists_3 = IterableExtensions.<String>exists(this.domainNamespaces, _function_5);
              _and_1 = ((ns instanceof DomainNamespace) && _exists_3);
            }
            if (_and_1) {
              this.compile(((SubNamespace) ns), resource);
            }
            boolean _and_2 = false;
            if (!(ns instanceof InternalNamespace)) {
              _and_2 = false;
            } else {
              final Function1<String,Boolean> _function_6 = new Function1<String,Boolean>() {
                  public Boolean apply(final String nsName) {
                    QualifiedName _fullyQualifiedName = DefaultBindingContractGenerators.this.nameProvider.getFullyQualifiedName(ns);
                    String _string = _fullyQualifiedName.toString();
                    boolean _matches = Pattern.matches(nsName, _string);
                    return Boolean.valueOf(_matches);
                  }
                };
              boolean _exists_4 = IterableExtensions.<String>exists(this.internalNamespaces, _function_6);
              _and_2 = ((ns instanceof InternalNamespace) && _exists_4);
            }
            if (_and_2) {
              this.compile(((SubNamespace) ns), resource);
            }
          }
        }
      }
    }
  }
  
  protected void compile(final ModuleBinding bind, final SOAProfile profile) {
    String _name = bind.getName();
    String _plus = ("Generating contracts for module binding " + _name);
    this.logger.info(_plus);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(this.noDependencies, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _notEquals_1 = (!Objects.equal(this.includeSubNamespaces, null));
      _and = (_notEquals && _notEquals_1);
    }
    if (_and) {
      this.bindingBuilder.build(bind, profile, (this.noDependencies).booleanValue(), (this.includeSubNamespaces).booleanValue());
    } else {
      this.bindingBuilder.build(bind, profile);
    }
  }
  
  protected void compile(final Module mod, final VersionedModuleSelector moduleSelector, final SOAProfile profile, final Resource resource) {
    String _name = mod.getName();
    String _plus = ("Generating contracts for module " + _name);
    String _plus_1 = (_plus + " version ");
    Version _version = mod.getVersion();
    String _version_1 = _version.getVersion();
    String _plus_2 = (_plus_1 + _version_1);
    this.logger.info(_plus_2);
    final Environment env = this.eObjectLookup.<Environment>getModelElementByName(this.targetEnvironmentName, resource, "Environment");
    boolean generateProvidedServices = moduleSelector.isGenerateProvidedServices();
    boolean generateUsedServices = moduleSelector.isGenerateUsedServices();
    boolean _and = false;
    boolean _not = (!generateProvidedServices);
    if (!_not) {
      _and = false;
    } else {
      boolean _not_1 = (!generateUsedServices);
      _and = (_not && _not_1);
    }
    if (_and) {
      generateUsedServices = true;
    }
    boolean _notEquals = (!Objects.equal(env, null));
    if (_notEquals) {
      String _endpointQualifier = moduleSelector.getEndpointQualifier();
      boolean _notEquals_1 = (!Objects.equal(_endpointQualifier, null));
      if (_notEquals_1) {
        final EndpointQualifierRef endpointQualifierRef = ModuleDslFactory.eINSTANCE.createEndpointQualifierRef();
        String _endpointQualifier_1 = moduleSelector.getEndpointQualifier();
        final Qualifier endpointQualifier = this.eObjectLookup.<Qualifier>getModelElementByName(_endpointQualifier_1, resource, "Qualifier");
        boolean _notEquals_2 = (!Objects.equal(endpointQualifierRef, null));
        if (_notEquals_2) {
          endpointQualifierRef.setEndpointQualifier(endpointQualifier);
          this.bindingBuilder.build(mod, env, generateProvidedServices, generateUsedServices, endpointQualifierRef, profile);
        } else {
          String _endpointQualifier_2 = moduleSelector.getEndpointQualifier();
          String _plus_3 = ("The provider endpoint-qualifier " + _endpointQualifier_2);
          String _plus_4 = (_plus_3 + " is not defined.");
          this.logger.severe(_plus_4);
        }
      } else {
        this.bindingBuilder.build(mod, env, generateProvidedServices, generateUsedServices, null, profile);
      }
    } else {
      String _plus_5 = ("No environment found matching the name expression " + this.targetEnvironmentName);
      this.logger.severe(_plus_5);
    }
  }
  
  protected void compile(final SubNamespace namespace, final Resource resource) {
    final SOAProfile profile = this.eObjectLookup.<SOAProfile>getModelElementByName(this.profileName, resource, "SOAProfile");
    final Environment env = this.eObjectLookup.<Environment>getModelElementByName(this.targetEnvironmentName, resource, "Environment");
    boolean _equals = Objects.equal(env, null);
    if (_equals) {
      String _plus = ("No environment found matching the name expression " + this.targetEnvironmentName);
      this.logger.severe(_plus);
    }
    boolean _equals_1 = Objects.equal(profile, null);
    if (_equals_1) {
      String _plus_1 = ("No architecture profile found matching the name " + this.profileName);
      this.logger.severe(_plus_1);
    }
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(env, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _notEquals_1 = (!Objects.equal(profile, null));
      _and = (_notEquals && _notEquals_1);
    }
    if (_and) {
      QualifiedName _fullyQualifiedName = this.nameProvider.getFullyQualifiedName(namespace);
      String _string = _fullyQualifiedName.toString();
      String _plus_2 = ("Generating XSDs for namespace " + _string);
      this.logger.info(_plus_2);
      this.xsdGen.toXSD(namespace, env, profile);
    }
  }
}
