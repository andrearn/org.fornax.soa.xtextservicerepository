/*
Copyright (c) 2010-2011 André Arnold and others.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
    André Arnold 		- initial API and implementation
    Christian Schneider	- reviews
    Krunoslav Markotic	- reviews
    Vitaly Markin
    Liane Lenke
*/
grammar org.fornax.soa.ServiceDsl with org.fornax.soa.basedsl.SOABaseDsl

generate serviceDsl "http://www.fornax.org/soa/ServiceDsl"

import "platform:/resource/org.fornax.soa.profiledsl/src-gen/org/fornax/soa/profiledsl/SOAProfileDsl.ecore" as profileDsl
import "platform:/resource/org.fornax.soa.semanticsdsl/src-gen/org/fornax/soa/SemanticsDsl.ecore" as semanticsDsl
import "platform:/resource/org.fornax.soa.businessdsl/src-gen/org/fornax/soa/BusinessDsl.ecore" as businessDsl

ServiceModel:
	(imports+=Import)*
	(orgNamespaces+=OrganizationNamespace)*
	(types+=Type)*;
	
/*
 * The toplevel namespace of the organization
 */
OrganizationNamespace :
	'org-namespace' name= QualifiedName ('shortname' prefix=STRING)? '{'
		('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
		(subNamespaces+=SubNamespace)*
	'}' ;

SubNamespace : DomainNamespace | InternalNamespace;
	
/* Namespace of a canonical domain subject to SOA governance rules*/
DomainNamespace:
	'domain-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		('metadata' '{'
			('domain' domain=[businessDsl::Domain|QualifiedName])?
			(version=Version  )?
			('namespace-owner' owner=STRING)?
			('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}')?
		(types+=Type)*
		(services+=Service)*
		(channels+=Channel)*
		(exceptions+=Exception)*
		(events+=GlobalEvent)*
		(interalNamespaces+=InternalNamespace)*
	'}';

/* Namespace for internal use with no restrictions */
InternalNamespace:	
	'internal-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		('metadata' '{'
			(version=Version)?
			('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}')?
		(types+=Type)*
		(services+=Service)*
		(exceptions+=Exception)*
		(events+=GlobalEvent)*
		(interalNamespaces+=InternalNamespace)*
	'}';
		
Type:
	VersionedType;

VersionedType:
	BusinessObject | Enumeration | QueryObject;		

BusinessObject:
	(abstract?='abstract')? 'businessObject'  name=ID ('extends' superBusinessObject=BusinessObjectRef)? '{' 
		'metadata' '{'
			version=Version 
			('replaces' replaces=BusinessObjectRef)?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			(governanceDecisions+=GovernanceDecision)*
			(
				('release-on' releaseDate = STRING )?
			&	('retirement-on' retirementDate = STRING)?
			&	('provided-contract' providedContractUrl=STRING)?
			)
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}'
		(properties+=Property)*
	'}';
	
QueryObject:
	'queryObject'  name=ID ('extends' superBusinessObject=BusinessObjectRef)? '{' 
		'metadata' '{'
			version=Version 
			('replaces' replaces=QueryObjectRef)?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			(governanceDecisions+=GovernanceDecision)*
			(
				('release-on' releaseDate = STRING )?
			&	('retirement-on' retirementDate = STRING)?
			&	('provided-contract' providedContractUrl=STRING)?
			)
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}'
		(properties+=Property)*
	'}';

TypeRef : DataTypeRef | AbstractVersionedTypeRef;

DataTypeRef: 
	type=[profileDsl::DataType|QualifiedName] (many?='[]' (set?='as set')? )? ;

AbstractVersionedTypeRef:  VersionedTypeRef | EnumTypeRef | BusinessObjectRef;

VersionedTypeRef:
	type=[VersionedType|QualifiedName] (many?='[]' (set?='as set')? )? versionRef=VersionRef;

	 
EnumTypeRef:
	type=[Enumeration|QualifiedName] versionRef=VersionRef;

BusinessObjectRef:
	type=[BusinessObject|QualifiedName] versionRef=VersionRef;

QueryObjectRef:
	type=[QueryObject|QualifiedName] versionRef=VersionRef;

	
Property:
	Attribute | Reference;

/* A simple attribute */	
Attribute:
	(deprecated?='@deprecated')? 
	(((optional?='optional')? (weak?='weak')?) | (isBusinessKey?='business-key')? | (isProvidedKey?='provided-key')?) 
	((historizingKey?='historizing-key') | (historized?='historized') | (versionIndependantKey?='version-independant-key'))? 
	name=ID ':' type=TypeRef ;
	
/* links to a target businessObject but uses it's business-key to resolve a reference, hence it is a weak reference */
Reference:
	(deprecated?='@deprecated')? 
	(((optional?='optional')? (weak?='weak')?) | (isBusinessKey?='business-key')? | (isProvidedKey?='provided-key')?) 
	'weak-ref' (historized?='historized')? name=ID ':' type=TypeRef; 
	
SimpleAttribute:
	(deprecated?='@deprecated')? (optional?='optional')? name=ID ':' type=TypeRef;
	
Enumeration:
	'enum' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EnumTypeRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			(
				('release-on' releaseDate = STRING )?
			&	('retirement-on' retirementDate = STRING )?
			&	('provided-contract' providedContractUrl=STRING)?
			)
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(literals+=EnumLiteral )*
	'}';
	
EnumLiteral: 
	(deprecated?='@deprecated')? name=ID;
	
// -- Technical eternal entities



Service:
	visibility=Visibility 'service' name=ID '{'
		'metadata' '{'
			version=Version  
			/*
			 * Used in conjunction with renaming the service. Points to the previous service version
			 */
			('replaces' replaces=ServiceRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			(governanceDecisions+=GovernanceDecision)*
			'service-category' category=[profileDsl::ServiceCategory | QualifiedName]
			/* To what extend is a service stateful or stateless */ 
			'statefulness' statefulness=Statefulness
			/* are data persisted by the service ? */ 
			('persistence' persistence=Persistence )? 
			(
				/* Who is responsible for the service? */
				('service-owner' owner=STRING )?
				/* The business capabilities the service fully implements */
			&	('realizes-capabilty' '{'(realizedCapabilies+=CapabilityRef)+ '}')?
				/* The business capabilities that are supported but not fully implemented by this service alone */	
			&	('supports-capabilty' '{'(supportedCapabilies+=CapabilityRef)+ '}')?
				/* 
				 * A technical service contract to be used instead of the one generation from this service definition.
				 * This should only be used with private services, as the technical contract might not meet the architectural
				 * rules that apply to public and domain scoped services
				 */	
			&	('provided-contract' providedContractUrl=STRING )? 
				/*
				 * Location of documentation or specification documents
				 */
			&	('document-location' documentUrl=STRING )?
				/*
				 * Date, when the service will be or has been released to production
				 */
			&	('release-on' releaseDate = STRING )?
				/*
				 * Date, when the service will be or was put out of service
				 */
			&	('retirement-on' retirementDate = STRING )?
				/*
				 * The message header definition being used. Overrides the default from the architecture profile
				 */
			&	('messageHeader' messageHeader = MessageHeaderRef )?
			)
			/*
			 * Semantic tagging
			 */
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		/*
		 * The service operations
		 */
		(operations+=Operation)*
	'}';
	

/* 
 * reflects SOA governance approval decisions
 * voteing until date will be part of the review ballots captured in the side store
 */
GovernanceApproval:
	'governance-approval' '{'
		decision=ApprovalDecision 
		('justification-doc' justificationOrDocURL=STRING )?
		('decision-date' approvalDate=STRING )? 
		('decision-by' approvedBy=STRING )?
	'}'; 
	
enum ApprovalDecision: no | yes | temporarily_tolerated="temporarily-tolerated" | tolerated | denied;
	
enum Statefulness: 
	/* same result, no matter how often the operation has been called with the same parameters*/
	idempotent | 
	stateless |
	/* Operation acts as if stateless, however a state transiently exists */ 
	transientState="transient-state"| 
	stateful
;

enum Persistence: none | read | write | readWrite = "read / write";

/* references a service applying a version constraint */
ServiceRef:
	service=[Service|QualifiedName] versionRef=VersionRef (isResponseHandler?='handling responses')?;

RequiredServiceRef:
	service=[Service|QualifiedName] versionRef=VersionRef (isResponseHandler?='handling responses')? ('calling' (calledOperations+=SimpleOperationRef) (',' calledOperations+=SimpleOperationRef)*)?;
	
OperationRef:
	operation=[Operation|QualifiedName] versionRef=VersionRef;
	
SimpleOperationRef: 
	operation=[Operation|QualifiedName];
	
PropertyRef:
	property=[Property|QualifiedName] versionRef=VersionRef;
	
	
// Fetch specifications for data retrieval
		
ConsiderationParameterRef:
	'parameter' param=[Parameter|QualifiedName] '->' '{' (propertyRef+=ConsiderationPropertyRef
	)+ '}';
	
ConsiderationPropertyRef:
	SimpleConsiderationPropertyRef | ComplexFetchPropertyRef
;

SimpleConsiderationPropertyRef:
	property=[Property|QualifiedName]
;

ComplexFetchPropertyRef:
	
	(fetchPropertyRef = SimpleConsiderationPropertyRef 
	( 
		(flat?='flat-only') | 
		'->' '{' 
			(nestedPropertyRef+=ConsiderationPropertyRef
			)+
		'}')
	)
;


MessageHeaderRef:
	header = [profileDsl::MessageHeader|QualifiedName] versionRef=VersionRef;

/*
 * References a business capability
 */
CapabilityRef:
	capability=[businessDsl::Capability|QualifiedName] versionRef=VersionRef;

Event:	GlobalEvent | OperationEvent;

/*
 * Event, that is not scoped to an operation
 */
GlobalEvent:
	'event' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EventRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName] 
			(governanceApproval=GovernanceApproval)?
			(governanceDecisions+=GovernanceDecision)*
			('release-on' releaseDate = STRING )?
			('retirement-on' retirementDate = STRING )?
			('provided-contract' providedContractUrl=STRING)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(parameter+=Parameter )*
	'}';

/*
 * Event that is scoped to an operation
 */
OperationEvent:
	'event' name=ID '{'
		('metadata' '{'
			('provided-contract' providedContractUrl=STRING)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}')?
		(parameter+=Parameter )*
	'}';
	
EventRef:	OperationEventRef | GlobalEventRef ;

OperationEventRef:
	event=[OperationEvent|QualifiedName] versionRef=VersionRef ('subType' subType=ID)?;

GlobalEventRef:
	event=[GlobalEvent|QualifiedName] versionRef=VersionRef ('subType' subType=ID)?;

/*
 * Channel used to publish events to or to watch for events
 */
Channel:
	(isTopic?='topic')? 'channel' name=QualifiedName  ;
	
/*
 * A service operation
 */
Operation:
	(deprecated?='@deprecated')? mep=MEP (transactional?='transactional')? name=ID '(' (parameters+=Parameter)?(',' parameters+=Parameter)* ')' ('returns' (return+=Parameter) (',' return+=Parameter)*)? ('throws' (throws+=ExceptionRef)?(',' throws+=ExceptionRef)*)? '{'
		/*
		 * Listens for callback from the given operations. Used, when one of the operations has been called asynchronously.
		 * The operation must correlate the asynch response to the original request
		 */
		('callback-listener-for' (callbackForOperation+=OperationRef) (',' callbackForOperation+=OperationRef)*)?
		/* The following event are published, when the operation is called */
		('publishes' '{'
				(publishes+=PublishedEvent )+ 
		'}')?
		/*
		 * The operation is automaitically invoked, when one of the given events occurs
		 */ 
		('subscribes-to' '{'
			(subscribes+=EventRef )
		'}')? 
		/*
		 * Services used by this service
		 */
		('requires' requires+=RequiredServiceRef )*
		/*
		 * overrides the default from the service
		 */ 
		('statefulness' statefulness=Statefulness (updating?='updating')? )?
		('persistence' persistence=Persistence )? 
		('transaction-spec' transactionSpec=TransactionSpec)?
		/*
		 * The operation is capabale to revert/compensate the effect of this operation
		 */
		('compensated-by' compensatedBy+=OperationRef )?
		/*
		 * Overrides the message header declaration from the architecture profile or service for this operation
		 */
		('messageHeader' messageHeader = MessageHeaderRef )?
		(consideration=ConsiderationProfile)?
		(fetchProfile+=FetchProfile)*
		('realizes-capabilty' '{'(realizedCapabilies+=CapabilityRef)+ '}')?	
		('supports-capabilty' '{'(supportedCapabilies+=CapabilityRef)+ '}')?	
		('tags' (tags+=[semanticsDsl::Tag])+)*
	'}';
	/*Callback is used optionally. In case of callback patterns, either the explicitly defined callback is used or the callback operation derived by convention. The convention is based on the name of the operation + "Callback" */

enum TransactionSpec:
	requiresNew = "requires-new" | requires='requires' | mandatory
;

/*
 * Defines the publishing of an event.
 */
PublishedEvent : PublishedGlobalEvent | PublishedOperationEvent;

/*
 * An event published by the operation
 */
PublishedOperationEvent: 
	publishesOpEvent = OperationEvent;

/*
 * Declares an event being published. Not scoped to the service operation.
 */
PublishedGlobalEvent:
	 publishesGlobalEvent = GlobalEventRef ;

/*
 * An operation (return) parameter
 */	 
Parameter:
	(optional?='optional')? name=ID ':' type=TypeRef ;

/*
 * Declared service operation exceptions
 */
Exception:
	'exception' name=ID ('extends' superException=ExceptionRef)? '{' 
		'metadata' '{'
			version=Version  
			('replaces' replaces=ExceptionRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName] 
			(governanceApproval=GovernanceApproval)?
			(governanceDecisions+=GovernanceDecision)*
			('release-on' releaseDate = STRING )?
			('retirement-on' retirementDate = STRING )?
			('provided-contract' providedContractUrl=STRING)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(properties+=SimpleAttribute)*
	'}';

ExceptionRef:
	exception=[Exception|QualifiedName] version=VersionRef;
	
/* the message exchange pattern */
enum MEP : 
	sync | async | oneway | fireForget='fire+forget' | deferredResponse='deferred' | syncAsync='sync+async'; 

/**
 * public:	usable by anyone, potentially remotely available
 * domain:	usable by all services in the same namespace or a subnamespace, potentially remotely available
 * private:	for internal use only, not remotely available on an ESB
 */	
enum Visibility : public | domain | private; 

/*
 * Defines what data will be fetch. Consumers can rely on respective BO properties being set
 */
FetchProfile:
	'fetch-profile' (isDefault?='default')? profileName=ID fetchSpec=FetchSpec ;

FetchSpec: EagerFetch | FlatFetch;

/*
 * Defines object properties to be always fetched
 */
EagerFetch: 
	'fetches' '{' 
		eagerFetchAssoc+=ConsiderationParameterRef+ 
	'}';

/*
 * Don't fetch properties of nested objects
 */
FlatFetch: 'fetches-flat-only' {FlatFetch};

ConsiderationProfile:
	'considers' '{' 
		consideredParam+=ConsiderationParameterRef+ 
	'}';
