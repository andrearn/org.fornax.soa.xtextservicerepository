/*
Copyright (c) 2010-2011 André Arnold and others.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
    André Arnold 		- initial API and implementation
    Christian Schneider	- reviews
    Krunoslav Markotic	- reviews
    Vitaly Markin
    Liane Lenke
*/
grammar org.fornax.soa.ServiceDsl with org.fornax.soa.basedsl.SOABaseDsl

generate serviceDsl "http://www.fornax.org/soa/ServiceDsl"

import "platform:/resource/org.fornax.soa.profiledsl/src-gen/org/fornax/soa/profiledsl/SOAProfileDsl.ecore" as profileDsl
import "platform:/resource/org.fornax.soa.semanticsdsl/src-gen/org/fornax/soa/SemanticsDsl.ecore" as semanticsDsl
import "platform:/resource/org.fornax.soa.businessdsl/src-gen/org/fornax/soa/BusinessDsl.ecore" as businessDsl

ServiceModel hidden(WS):
	(imports+=Import)*
	(orgNamespaces+=OrganizationNamespace)*
	(types+=Type)*;
	

OrganizationNamespace :
	'org-namespace' name= QualifiedName ('shortname' prefix=STRING)? '{'
		('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
		(subNamespaces+=SubNamespace)*
	'}' ;

SubNamespace : DomainNamespace | InternalNamespace;
	
DomainNamespace:
	(doc=ML_COMMENT)? 
	'domain-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		'metadata' '{'
			('domain' domain=[businessDsl::Domain|QualifiedName])?
			(version=Version  )?
			('namespace-owner' owner=STRING)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}'
		(types+=Type)*
		(services+=Service)*
		(channels+=Channel)*
		(exceptions+=Exception)*
		(events+=GlobalEvent)*
		(interalNamespaces+=InternalNamespace)*
	'}';

InternalNamespace:	
	(doc=ML_COMMENT)? 
	'internal-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		'metadata' '{'
			(version=Version)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}'
		(types+=Type)*
		(services+=Service)*
		(exceptions+=Exception)*
		(events+=GlobalEvent)*
		(interalNamespaces+=InternalNamespace)*
	'}';
	
LinkingPolicy :
	'deployment-policy' '{'
		'minimal-development-state' minDevState = [profileDsl::LifecycleState | QualifiedName] 
		'minimal-test-state' minTestState = [profileDsl::LifecycleState | QualifiedName]
		'minimal-production-state' minProdState = [profileDsl::LifecycleState | QualifiedName]
	'}';
	
Type:
	VersionedType;

VersionedType:
	BusinessObject | Enumeration;
		

BusinessObject:
	(doc=ML_COMMENT)?
	(abstract?='abstract')? 'businessObject'  name=ID ('extends' superBusinessObject=BusinessObjectRef)? '{' 
		'metadata' '{'
			version=Version 
			('replaces' replaces=BusinessObjectRef)?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			('retirement-on' retirementDate = STRING)?
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}'
		(properties+=Property)*
	'}';

TypeRef : DataTypeRef | AbstractVersionedTypeRef;

DataTypeRef: 
	type=[profileDsl::DataType|QualifiedName] (many?='[]' (set?='as set')? )? ;

AbstractVersionedTypeRef:  VersionedTypeRef | EnumTypeRef | BusinessObjectRef;

VersionedTypeRef:
	type=[VersionedType|QualifiedName] (many?='[]' (set?='as set')? )? versionRef=VersionRef;

	 
EnumTypeRef:
	type=[Enumeration|QualifiedName] versionRef=VersionRef;

BusinessObjectRef:
	type=[BusinessObject|QualifiedName] versionRef=VersionRef;

	
Property:
	Attribute | Reference;
	
Attribute:
	(doc=ML_COMMENT)?
	(deprecated?='@deprecated')? 
	((optional?='optional')? | (shallow?='shallow')? | (isBusinessKey?='business-key')? | (isProvidedKey?='provided-key')?) 
	((historizingKey?='historizing-key') | (historized?='historized') | (versionIndependantKey?='version-independant-key'))? 
	name=ID ':' type=TypeRef ;
	
//links to a target businessObject but uses it's business-key to resolve a reference, hence it is a weak reference
Reference:
	(doc=ML_COMMENT)?
	(deprecated?='@deprecated')? 
	((optional?='optional')? | (shallow?='shallow')? | (isBusinessKey?='business-key')? | (isProvidedKey?='provided-key')?) 
	'weak-ref' (historized?='historized')? name=ID ':' type=TypeRef; 
	
SimpleAttribute:
	(doc=ML_COMMENT)?
	(deprecated?='@deprecated')? (optional?='optional')? name=ID ':' type=TypeRef;
	
Enumeration:
	(doc=ML_COMMENT)?
	'enum' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EnumTypeRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			('retirement-on' retirementDate = STRING )?
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(literals+=EnumLiteral )*
	'}';
	
EnumLiteral: 
	(doc=ML_COMMENT)?
	(deprecated?='@deprecated')? name=ID;
	
// -- Technical eternal entities



Service hidden(WS):
	(doc=ML_COMMENT)?
	visibility=VISIBILITY 'service' name=ID '{'
		'metadata' '{'
			version=Version  
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			'service-category' category=ServiceCategory 
			'statefulness' statefulness=Statefulness 
			('persistence' persistence=Persistence )? 
			(
				('service-owner' owner=STRING )?
			&	('realizes-capabilty' '{'(realizedCapabilies+=CapabilityRef)+ '}')?	
			&	('supports-capabilty' '{'(supportedCapabilies+=CapabilityRef)+ '}')?	
			&	('provided-Contract-URL' providedContractUrl=STRING )? //Where can I get the sources?
			&	('sourceURL' source=STRING )? //Where can I get the sources?
			&	('docURL' docUrl=STRING )?
			&	('release-on' releaseDate = STRING )?
			&	('retirement-on' retirementDate = STRING )?
			&	('replaces' replaces=ServiceRef )?
			&	('messageHeader' messageHeader = MessageHeaderRef )?
			&   (linkingPolicy = LinkingPolicy)?
			)
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(operations+=Operation)*
	'}';
	
enum ServiceCategory: process | rule | activity | entity | utility;


GovernanceApproval:
	'governance-approval' '{'
		decision=ApprovalDecision 
		('justification-doc' justificationOrDocURL=STRING )?
		('decision-date' approvalDate=STRING )? 
		('decision-by' approvedBy=STRING )?
	'}'; 
	
enum ApprovalDecision: no | yes | temporarily_tolerated="temporarily-tolerated" | tolerated;
	
enum Statefulness: idempotent | stateless | transientState="transient-state"| stateful ;

enum Persistence: none | read | write | readWrite = "read / write";

ServiceRef:
	service=[Service|QualifiedName] versionRef=VersionRef (isResponseHandler?='handling responses')?;
	
OperationRef:
	operation=[Operation|QualifiedName] versionRef=VersionRef;
	
PropertyRef:
	property=[Property|QualifiedName] versionRef=VersionRef;
	
ParameterRef:
	param=[Parameter|QualifiedName] '->' property=[Property|QualifiedName];

MessageHeaderRef:
	header = [profileDsl::MessageHeader|QualifiedName] versionRef=VersionRef;
	
CapabilityRef:
	capability=[businessDsl::Capability|QualifiedName] versionRef=VersionRef;

Event:	GlobalEvent | OperationEvent;

GlobalEvent:
	'event' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EventRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName] 
			(governanceApproval=GovernanceApproval)?
			('retirement-on' retirementDate = STRING )?
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(parameter+=Parameter )*
	'}';
	
OperationEvent:
	'event' name=ID '{'
		('metadata' '{'
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}')?
		(parameter+=Parameter )*
	'}';
	
EventRef:	OperationEventRef | GlobalEventRef ;

OperationEventRef:
	event=[OperationEvent|QualifiedName] versionRef=VersionRef ('subType' subType=ID)?;

GlobalEventRef:
	event=[GlobalEvent|QualifiedName] versionRef=VersionRef ('subType' subType=ID)?;
	
Channel:
	'channel' name=QualifiedName  ;
	
	
Operation:
	(doc=ML_COMMENT)?
	(deprecated?='@deprecated')? mep=MEP name=ID '(' (parameters+=Parameter)?(',' parameters+=Parameter)* ')' ('returns' (return+=Parameter) (',' return+=Parameter)*)? ('throws' (throws+=ExceptionRef)?(',' throws+=ExceptionRef)*)? '{'
		('callback-listener-for' (callbackForOperation+=OperationRef) (',' callbackForOperation+=OperationRef)*)?
		('publishes' '{'
				(publishes+=PublishedEvent )+ 
		'}')? 
		('subscribes-to' '{'
			(subscribes+=EventRef )
		'}')? 
		('requires' requires+=ServiceRef )* 
		('statefulness' statefulness=Statefulness (updating?='updating')? )?
		('can-compensate' canCompensate+=OperationRef )?
		('messageHeader' messageHeader = MessageHeaderRef )?
		(fetchProfile+=FetchProfile)*
		('realizes-capabilty' '{'(realizedCapabilies+=CapabilityRef)+ '}')?	
		('supports-capabilty' '{'(supportedCapabilies+=CapabilityRef)+ '}')?	
	'}';
	/*Callback is used optionally. In case of callback patterns, either the explicitly defined callback is used or the callback operation derived by convention. The convention is based on the name of the operation + "Callback" */

PublishedEvent : PublishedGlobalEvent | PublishedOperationEvent;

PublishedOperationEvent: 
	publishesOpEvent = OperationEvent;

PublishedGlobalEvent:
	 publishesGlobalEvent = GlobalEventRef ;
	 
Parameter:
	(optional?='optional')? name=ID ':' type=TypeRef ;
	
Exception:
	(doc=ML_COMMENT)?
	'exception' name=ID ('extends' superException=ExceptionRef)? '{' 
		'metadata' '{'
			version=Version  
			('replaces' replaces=ExceptionRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName] 
			(governanceApproval=GovernanceApproval)?
			('retirement-on' retirementDate = STRING )?
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			(linkingPolicy = LinkingPolicy)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(properties+=SimpleAttribute)*
		(wrappedExceptions+=ExceptionRef)*
	'}';

ExceptionRef:
	exception=[Exception|QualifiedName] version=VersionRef;
	
enum MEP : 
	sync | async | oneway | fireForget='fire+forget'; 

/**
 * public:	usable by anyone, potentially remotely available
 * domain:	usable by all services in the same namespace or a subnamespace, potentially remotely available
 * private:	for internal use only
 */	
enum VISIBILITY : public | domain | private; 

FetchProfile:
	'fetch-profile' (isDefault?='default')? profileName=ID fetchSpec=FetchSpec ;

FetchSpec: EagerFetch | FlatFetch;

EagerFetch: 'fetches' (eagerFetchAssoc+=ParameterRef)(',' eagerFetchAssoc+=ParameterRef)*;

FlatFetch: 'fetches-flat-only' {FlatFetch};
