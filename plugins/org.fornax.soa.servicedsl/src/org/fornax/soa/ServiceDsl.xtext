/*
Copyright (c) 2010-2011 André Arnold and others.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
    André Arnold 		- initial API and implementation
    Christian Schneider	- reviews
    Krunoslav Markotic	- reviews
    Vitaly Markin
    Liane Lenke
*/
grammar org.fornax.soa.ServiceDsl with org.fornax.soa.basedsl.SOABaseDsl

generate serviceDsl "http://www.fornax.org/soa/ServiceDsl"

import "platform:/resource/org.fornax.soa.profiledsl/src-gen/org/fornax/soa/profiledsl/SOAProfileDsl.ecore" as profileDsl
import "platform:/resource/org.fornax.soa.semanticsdsl/src-gen/org/fornax/soa/SemanticsDsl.ecore" as semanticsDsl
import "platform:/resource/org.fornax.soa.businessdsl/src-gen/org/fornax/soa/BusinessDsl.ecore" as businessDsl

ServiceModel:
	(imports+=Import)*
	(orgNamespaces+=OrganizationNamespace)*
	(types+=Type)*;
	
/*
 * The toplevel namespace of the organization
 */
OrganizationNamespace :
	'org-namespace' name= QualifiedName ('shortname' prefix=STRING)? '{'
		('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
		(subNamespaces+=SubNamespace)*
	'}' ;

SubNamespace : DomainNamespace | InternalNamespace;
	
/* Namespace of a canonical domain subject to SOA governance rules*/
DomainNamespace:
	'domain-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		('metadata' '{'
			('domain' domain=[businessDsl::Domain|QualifiedName])?
			(version=Version  )?
			('namespace-owner' owner=STRING)?
			('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}')?
		(types+=Type)*
		(services+=Service)*
		(channels+=Channel)*
		(exceptions+=Exception)*
		(events+=GlobalEvent)*
		(interalNamespaces+=InternalNamespace)*
	'}';

/* Namespace for internal use with no restrictions */
InternalNamespace:	
	'internal-namespace' name=QualifiedName ('shortname' prefix=STRING)? '{'
		('metadata' '{'
			(version=Version)?
			('architecture-profile' profile = [profileDsl::SOAProfile|QualifiedName])?
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}')?
		(types+=Type)*
		(services+=Service)*
		(exceptions+=Exception)*
		(events+=GlobalEvent)*
		(interalNamespaces+=InternalNamespace)*
	'}';
		
Type:
	VersionedType;

VersionedType:
	BusinessObject | Enumeration;
		

BusinessObject:
	(abstract?='abstract')? 'businessObject'  name=ID ('extends' superBusinessObject=BusinessObjectRef)? '{' 
		'metadata' '{'
			version=Version 
			('replaces' replaces=BusinessObjectRef)?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			(
				('release-on' releaseDate = STRING )?
			&	('retirement-on' retirementDate = STRING)?
			&	('provided-definition-URL' providedDefinitionUrl=STRING)?
			)
			('tags' (tags+=[semanticsDsl::Tag])+)*
		'}'
		(properties+=Property)*
	'}';

TypeRef : DataTypeRef | AbstractVersionedTypeRef;

DataTypeRef: 
	type=[profileDsl::DataType|QualifiedName] (many?='[]' (set?='as set')? )? ;

AbstractVersionedTypeRef:  VersionedTypeRef | EnumTypeRef | BusinessObjectRef;

VersionedTypeRef:
	type=[VersionedType|QualifiedName] (many?='[]' (set?='as set')? )? versionRef=VersionRef;

	 
EnumTypeRef:
	type=[Enumeration|QualifiedName] versionRef=VersionRef;

BusinessObjectRef:
	type=[BusinessObject|QualifiedName] versionRef=VersionRef;

	
Property:
	Attribute | Reference;

/* A simple attribute */	
Attribute:
	(deprecated?='@deprecated')? 
	((optional?='optional')? | (weak?='weak')? | (isBusinessKey?='business-key')? | (isProvidedKey?='provided-key')?) 
	((historizingKey?='historizing-key') | (historized?='historized') | (versionIndependantKey?='version-independant-key'))? 
	name=ID ':' type=TypeRef ;
	
/* links to a target businessObject but uses it's business-key to resolve a reference, hence it is a weak reference */
Reference:
	(deprecated?='@deprecated')? 
	((optional?='optional')? | (isBusinessKey?='business-key')? | (isProvidedKey?='provided-key')?) 
	'weak-ref' (historized?='historized')? name=ID ':' type=TypeRef; 
	
SimpleAttribute:
	(deprecated?='@deprecated')? (optional?='optional')? name=ID ':' type=TypeRef;
	
Enumeration:
	'enum' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EnumTypeRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			(
				('release-on' releaseDate = STRING )?
			&	('retirement-on' retirementDate = STRING )?
			&	('provided-definition-URL' providedDefinitionUrl=STRING)?
			)
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(literals+=EnumLiteral )*
	'}';
	
EnumLiteral: 
	(deprecated?='@deprecated')? name=ID;
	
// -- Technical eternal entities



Service:
	visibility=VISIBILITY 'service' name=ID '{'
		'metadata' '{'
			version=Version  
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName]
			(governanceApproval=GovernanceApproval)?
			'service-category' category=[profileDsl::ServiceCategory | QualifiedName]
			/* To what extend is a service stateful or stateless */ 
			'statefulness' statefulness=Statefulness
			/* are data persisted by the service ? */ 
			('persistence' persistence=Persistence )? 
			(
				/* Who is responsible for the service? */
				('service-owner' owner=STRING )?
				/* The business capabilities the service fully implements */
			&	('realizes-capabilty' '{'(realizedCapabilies+=CapabilityRef)+ '}')?
				/* The business capabilities that are supported but not fully implemented by this service alone */	
			&	('supports-capabilty' '{'(supportedCapabilies+=CapabilityRef)+ '}')?
				/* 
				 * A technical service contract to be used instead of the one generation from this service definition.
				 * This should only be used with private services, as the technical contract might not meet the architectural
				 * rules that apply to public and domain scoped services
				 */	
			&	('provided-Contract-URL' providedContractUrl=STRING )? //Where can I get the sources?
				/*
				 * Location of the source code
				 */
			&	('sourceURL' source=STRING )? //Where can I get the sources?
				/*
				 * Location of documentation or specification documents
				 */
			&	('docURL' docUrl=STRING )?
				/*
				 * Date, when the service will be or has been released to production
				 */
			&	('release-on' releaseDate = STRING )?
				/*
				 * Date, when the service will be or was put out of service
				 */
			&	('retirement-on' retirementDate = STRING )?
				/*
				 * Used in conjunction with renaming the service. Points to the previous service version
				 */
			&	('replaces' replaces=ServiceRef )?
				/*
				 * The message header definition being used. Overrides the default from the architecture profile
				 */
			&	('messageHeader' messageHeader = MessageHeaderRef )?
			)
			/*
			 * Semantic tagging
			 */
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		/*
		 * The service operations
		 */
		(operations+=Operation)*
	'}';
	

/* reflects SOA governance decisions */
GovernanceApproval:
	'governance-approval' '{'
		decision=ApprovalDecision 
		('justification-doc' justificationOrDocURL=STRING )?
		('decision-date' approvalDate=STRING )? 
		('decision-by' approvedBy=STRING )?
	'}'; 
	
enum ApprovalDecision: no | yes | temporarily_tolerated="temporarily-tolerated" | tolerated;
	
enum Statefulness: 
	/* same result, no matter how often the operation has been called with the same parameters*/
	idempotent | 
	stateless |
	/* Operation acts as if stateless, however a state transiently exists */ 
	transientState="transient-state"| 
	stateful
;

enum Persistence: none | read | write | readWrite = "read / write";

/* references a service applying a version constraint */
ServiceRef:
	service=[Service|QualifiedName] versionRef=VersionRef (isResponseHandler?='handling responses')?;
	
OperationRef:
	operation=[Operation|QualifiedName] versionRef=VersionRef;
	
PropertyRef:
	property=[Property|QualifiedName] versionRef=VersionRef;
	
ParameterRef:
	param=[Parameter|QualifiedName] '->' property=[Property|QualifiedName];

MessageHeaderRef:
	header = [profileDsl::MessageHeader|QualifiedName] versionRef=VersionRef;

/*
 * References a business capability
 */
CapabilityRef:
	capability=[businessDsl::Capability|QualifiedName] versionRef=VersionRef;

Event:	GlobalEvent | OperationEvent;

/*
 * Event, that is not scoped to an operation
 */
GlobalEvent:
	'event' name=ID '{'
		'metadata' '{'
			version=Version  
			('replaces' replaces=EventRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName] 
			(governanceApproval=GovernanceApproval)?
			('release-on' releaseDate = STRING )?
			('retirement-on' retirementDate = STRING )?
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(parameter+=Parameter )*
	'}';

/*
 * Event that is scoped to an operation
 */
OperationEvent:
	'event' name=ID '{'
		('metadata' '{'
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}')?
		(parameter+=Parameter )*
	'}';
	
EventRef:	OperationEventRef | GlobalEventRef ;

OperationEventRef:
	event=[OperationEvent|QualifiedName] versionRef=VersionRef ('subType' subType=ID)?;

GlobalEventRef:
	event=[GlobalEvent|QualifiedName] versionRef=VersionRef ('subType' subType=ID)?;

/*
 * Channel used to publish events to or to watch for events
 */
Channel:
	'channel' name=QualifiedName  ;
	
/*
 * A service operation
 */
Operation:
	(deprecated?='@deprecated')? mep=MEP name=ID '(' (parameters+=Parameter)?(',' parameters+=Parameter)* ')' ('returns' (return+=Parameter) (',' return+=Parameter)*)? ('throws' (throws+=ExceptionRef)?(',' throws+=ExceptionRef)*)? '{'
		/*
		 * Listens for callback from the given operations. Used, when one of the operations has been called asynchronously.
		 * The operation must correlate the asynch response to the original request
		 */
		('callback-listener-for' (callbackForOperation+=OperationRef) (',' callbackForOperation+=OperationRef)*)?
		/* The following event are published, when the operation is called */
		('publishes' '{'
				(publishes+=PublishedEvent )+ 
		'}')?
		/*
		 * The operation is automaitically invoked, when one of the given events occurs
		 */ 
		('subscribes-to' '{'
			(subscribes+=EventRef )
		'}')? 
		/*
		 * Services used by this service
		 */
		('requires' requires+=ServiceRef )*
		/*
		 * overrides the default from the service
		 */ 
		('statefulness' statefulness=Statefulness (updating?='updating')? )?
		/*
		 * The operation is capabale to revert/compensate the effect ot the given other operation
		 */
		('can-compensate' canCompensate+=OperationRef )?
		/*
		 * Overrides the message header declaration from the architecture profile or service for this operation
		 */
		('messageHeader' messageHeader = MessageHeaderRef )?
		(fetchProfile+=FetchProfile)*
		('realizes-capabilty' '{'(realizedCapabilies+=CapabilityRef)+ '}')?	
		('supports-capabilty' '{'(supportedCapabilies+=CapabilityRef)+ '}')?	
	'}';
	/*Callback is used optionally. In case of callback patterns, either the explicitly defined callback is used or the callback operation derived by convention. The convention is based on the name of the operation + "Callback" */

/*
 * Defines the publishing of an event.
 */
PublishedEvent : PublishedGlobalEvent | PublishedOperationEvent;

/*
 * An event published by the operation
 */
PublishedOperationEvent: 
	publishesOpEvent = OperationEvent;

/*
 * Declares an event being published. Not scoped to the service operation.
 */
PublishedGlobalEvent:
	 publishesGlobalEvent = GlobalEventRef ;

/*
 * An operation (return) parameter
 */	 
Parameter:
	(optional?='optional')? name=ID ':' type=TypeRef ;

/*
 * Declared service operation exceptions
 */
Exception:
	'exception' name=ID ('extends' superException=ExceptionRef)? '{' 
		'metadata' '{'
			version=Version  
			('replaces' replaces=ExceptionRef )?
			'lifecycle-state' state=[profileDsl::LifecycleState | QualifiedName] 
			(governanceApproval=GovernanceApproval)?
			('release-on' releaseDate = STRING )?
			('retirement-on' retirementDate = STRING )?
			('provided-definition-URL' providedDefinitionUrl=STRING)?
			('tags' (tags+=[semanticsDsl::Tag])+ )*
		'}'
		(properties+=SimpleAttribute)*
		(wrappedExceptions+=ExceptionRef)*
	'}';

ExceptionRef:
	exception=[Exception|QualifiedName] version=VersionRef;
	
/* the message exchange pattern */
enum MEP : 
	sync | async | oneway | fireForget='fire+forget'; 

/**
 * public:	usable by anyone, potentially remotely available
 * domain:	usable by all services in the same namespace or a subnamespace, potentially remotely available
 * private:	for internal use only
 */	
enum VISIBILITY : public | domain | private; 

/*
 * Defines what data will be fetch. Consumers can rely on respective BO properties being set
 */
FetchProfile:
	'fetch-profile' (isDefault?='default')? profileName=ID fetchSpec=FetchSpec ;

FetchSpec: EagerFetch | FlatFetch;

/*
 * Defines object properties to be always fetched
 */
EagerFetch: 'fetches' (eagerFetchAssoc+=ParameterRef)(',' eagerFetchAssoc+=ParameterRef)*;

/*
 * Don't fetch properties of nested objects
 */
FlatFetch: 'fetches-flat-only' {FlatFetch};
