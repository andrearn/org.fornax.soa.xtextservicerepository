/*
 * generated by Xtext
 */
package org.xkonnex.repo.dsl.moduledsl.scoping;

import static com.google.common.collect.Lists.newArrayList;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.ImportNormalizer;
import org.xkonnex.repo.dsl.basedsl.baseDsl.FixedVersionRef;
import org.xkonnex.repo.dsl.basedsl.baseDsl.LowerBoundRangeVersionRef;
import org.xkonnex.repo.dsl.basedsl.baseDsl.MajorVersionRef;
import org.xkonnex.repo.dsl.basedsl.baseDsl.MaxVersionRef;
import org.xkonnex.repo.dsl.basedsl.baseDsl.MinVersionRef;
import org.xkonnex.repo.dsl.basedsl.baseDsl.VersionRef;
import org.xkonnex.repo.dsl.basedsl.scoping.ComponentAwareVersionedScopeProvider;
import org.xkonnex.repo.dsl.basedsl.scoping.MapBasedScope;
import org.xkonnex.repo.dsl.basedsl.scoping.versions.filter.AbstractPredicateVersionFilter;
import org.xkonnex.repo.dsl.basedsl.scoping.versions.filter.FixedVersionFilter;
import org.xkonnex.repo.dsl.basedsl.scoping.versions.filter.NullVersionFilter;
import org.xkonnex.repo.dsl.basedsl.search.IEObjectLookup;
import org.xkonnex.repo.dsl.basedsl.version.IScopeVersionResolver;
import org.xkonnex.repo.dsl.basedsl.version.SimpleScopeVersionResolver;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.AbstractResourceRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.AbstractServiceRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ImportServiceRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.Module;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ModuleDslPackage;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ModuleRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.NamespaceRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.OperationRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ProvidingEndpointProtocol;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ServiceModuleRef;
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ServiceRef;
import org.xkonnex.repo.dsl.moduledsl.query.IModuleServiceResolver;
import org.xkonnex.repo.dsl.moduledsl.query.ModuleLookup;
import org.xkonnex.repo.dsl.moduledsl.util.ModuleDslAccess;
import org.xkonnex.repo.dsl.profiledsl.profileDsl.LifecycleState;
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.ILifecycleStateResolver;
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedLatestMajorVersionForOwnerStateFilter;
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedLatestMinMaxVersionForOwnerStateFilter;
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedLatestMinVersionForOwnerStateFilter;
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedMaxVersionForOwnerStateFilter;
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.StateAttributeLifecycleStateResolver;
import org.xkonnex.repo.dsl.servicedsl.service.util.CandidateServicesPredicate;
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.Operation;
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.Parameter;
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.ResourceRef;
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.Service;
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.ServiceDslPackage;

import com.google.common.base.Predicate;
import com.google.common.collect.Maps;
import com.google.inject.Inject;
import com.google.inject.Injector;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class ModuleDslScopeProvider extends ComponentAwareVersionedScopeProvider {

	
	@Inject Injector injector;
	
	@Inject ModuleLookup modLookup;
	@Inject IModuleServiceResolver modServiceResolver;
	@Inject IQualifiedNameProvider nameProvider;
	@Inject ILifecycleStateResolver defaultStateResolver; 
	@Inject StateAttributeLifecycleStateResolver staticStateResolver; 
	@Inject IEObjectLookup objLookup;
	
	@Override
	public IScope getScope(EObject context, EReference reference) {
		if (reference == ModuleDslPackage.Literals.OPERATION_REF__OPERATION) {
			ServiceRef serviceRef = EcoreUtil2.getContainerOfType(context, ServiceRef.class);
			Map<QualifiedName, EObject> operationsMap = Maps.newHashMap();
			if (serviceRef.getService() != null) {
				EList<Operation> operations = serviceRef.getService().getOperations();
				for (Operation operation : operations) {
					operationsMap.put(QualifiedName.create(operation.getName()), operation);
				}
			}
			return new MapBasedScope(operationsMap);
		} else if (reference == ModuleDslPackage.Literals.PARAMETER_REF__PARAMETER) {
				OperationRef opRef = EcoreUtil2.getContainerOfType(context, OperationRef.class);
				Map<QualifiedName, EObject> parametersMap = Maps.newHashMap();
				if (opRef.getOperation() != null) {
					EList<Parameter> parameters = opRef.getOperation().getParameters();
					for (Parameter param : parameters) {
						parametersMap.put(QualifiedName.create(param.getName()), param);
					}
				}
				return new MapBasedScope(parametersMap);
		} else {
			return super.getScope(context, reference);
		}
	}

	@Override
	protected AbstractPredicateVersionFilter<IEObjectDescription> getVersionFilterFromContext(
			EObject context, EReference reference) {
		if (reference == ModuleDslPackage.Literals.ABSTRACT_SERVICE_REF__SERVICE && context instanceof ServiceRef) {
			final VersionRef v = ((ServiceRef) context).getVersionRef();
			if (context.eContainer() instanceof ModuleRef) {
				AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context, staticStateResolver);
				
				ModuleRef modRef = (ModuleRef) context.eContainer();
				Set<AbstractServiceRef> providedServiceRefs = modServiceResolver.getAllProvidedServiceRefs(modRef.getModuleRef().getModule());
				if (!providedServiceRefs.isEmpty()) {
					final List<QualifiedName> provServiceNames = new ArrayList<QualifiedName>();
					for (AbstractServiceRef provSvcRef : providedServiceRefs) {
						provServiceNames.add (nameProvider.getFullyQualifiedName(provSvcRef.getService()));
					}
					createServiceNameFilter(versionFilter, provServiceNames);
				}
				return versionFilter;
			} else if (context.eContainer() instanceof NamespaceRef) {
				AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context, staticStateResolver);
				NamespaceRef nsRef = (NamespaceRef)context.eContainer();
				List<Service> services = nsRef.getNamespace().getServices();
				final List<QualifiedName> provServiceNames = new ArrayList<QualifiedName>();
				for (Service provSvc : services) {
					provServiceNames.add (nameProvider.getFullyQualifiedName(provSvc));
				}
				createServiceNameFilter(versionFilter, provServiceNames);
				return versionFilter;
			} else {
				AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context, staticStateResolver);
				return versionFilter;
			}
		}
		if (reference == ModuleDslPackage.Literals.ABSTRACT_SERVICE_REF__SERVICE && context instanceof ImportServiceRef) {
			final VersionRef v = ((ImportServiceRef) context).getVersionRef();
			ImportServiceRef impSvcRef = (ImportServiceRef) context;
			Module owningModule = ModuleDslAccess.getOwningModule(impSvcRef);
			final List<ServiceModuleRef> candModules = impSvcRef.getModules();
			List<Service> candServices = new ArrayList<Service>();
			if (candModules.isEmpty()) {
				Set<Module> allModules = modLookup.findAllModules (context.eResource().getResourceSet());
				for (Module mod : allModules) {
					if (!mod.equals(owningModule)) {
						extractProvidedServices(context, candServices, mod);
					}
				}
			} else {
				for (ServiceModuleRef ref : candModules) {
					Module targetModule = ref.getModule();
					//TODO filter modules, that do not have one of the accepted qualifiers
					extractProvidedServices(context, candServices, targetModule);
				}
			}
 
			if (!candServices.isEmpty() && !candModules.isEmpty())
				return createVersionFilter(v, context, candServices, staticStateResolver);
			else
				return createVersionFilter(v, context, staticStateResolver);
		}
		if (reference == ModuleDslPackage.Literals.SERVICE_MODULE_REF__MODULE && context instanceof ServiceModuleRef) {
			final VersionRef v = ((ServiceModuleRef) context).getVersion();
			Module owningModule = ModuleDslAccess.getOwningModule (context);
			return createVersionFilter(v, owningModule, staticStateResolver);
		}
		if (reference == ModuleDslPackage.Literals.ABSTRACT_RESOURCE_REF__RESOURCE && context instanceof AbstractResourceRef) {
			final VersionRef v = ((AbstractResourceRef) context).getVersionRef();
			AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context, staticStateResolver);
			return versionFilter;
		}
		return new NullVersionFilter<IEObjectDescription>();
	}

	private void createServiceNameFilter(
			AbstractPredicateVersionFilter<IEObjectDescription> versionFilter,
			final List<QualifiedName> provServiceNames) {
		versionFilter.setPreFilterPredicate(new Predicate<IEObjectDescription> () {

			public boolean apply(IEObjectDescription input) {
				for (QualifiedName name : provServiceNames) {
					if (ServiceDslPackage.Literals.SERVICE.equals(input.getEClass()) && input.getQualifiedName() != null && name != null && input.getQualifiedName().startsWith(name)) {
						return true;
					}
				}
				return false;
			}
			
		});
	}

	private void extractProvidedServices(EObject context,
			List<Service> candServices, Module targetModule) {
		if (targetModule != null) {
			if (targetModule.eIsProxy())
				targetModule = (Module) EcoreUtil.resolve (targetModule, context.eResource().getResourceSet());
			Set<AbstractServiceRef> providedServiceRefs = modServiceResolver.getAllProvidedServiceRefs(targetModule);
			for (AbstractServiceRef svcRef : providedServiceRefs) {
				if (svcRef.eIsProxy()) {
					svcRef = (ServiceRef) EcoreUtil.resolve (svcRef, context.eResource().getResourceSet());
				}
				if (svcRef.getService() != null)
					candServices.add (svcRef.getService());
			}
		}
	}

	@Override
	protected AbstractPredicateVersionFilter<IEObjectDescription> createVersionFilter(final VersionRef v, EObject owner) {
		AbstractPredicateVersionFilter<IEObjectDescription> filter = new NullVersionFilter<IEObjectDescription>();
		if (v != null) {
			IScopeVersionResolver verResolver = new SimpleScopeVersionResolver (v.eResource().getResourceSet());
			if (!staticStateResolver.definesState(owner)) {
				owner = objLookup.getStatefulOwner(owner);
			}
			LifecycleState ownerState = staticStateResolver.getLifecycleState(owner);
			if (v instanceof MajorVersionRef) {
				RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> (verResolver, new Integer(((MajorVersionRef)v).getMajorVersion()).toString(), staticStateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof MaxVersionRef) {
				RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((MaxVersionRef)v).getMaxVersion(), staticStateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof MinVersionRef) {
				RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((MinVersionRef)v).getMinVersion(), staticStateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof LowerBoundRangeVersionRef) {
				RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((LowerBoundRangeVersionRef)v).getMinVersion(), ((LowerBoundRangeVersionRef)v).getMaxVersion(), staticStateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof FixedVersionRef)
				return new FixedVersionFilter<IEObjectDescription>(verResolver, ((FixedVersionRef) v).getFixedVersion());
		}
		return filter;
	}
	
	protected AbstractPredicateVersionFilter<IEObjectDescription> createVersionFilter(final VersionRef v, EObject owner, ILifecycleStateResolver stateResolver) {
		AbstractPredicateVersionFilter<IEObjectDescription> filter = new NullVersionFilter<IEObjectDescription>();
		if (v != null) {
			IScopeVersionResolver verResolver = new SimpleScopeVersionResolver (v.eResource().getResourceSet());
			if (!stateResolver.definesState(owner)) {
				owner = objLookup.getStatefulOwner(owner);
			}
			LifecycleState ownerState = stateResolver.getLifecycleState(owner);
			if (v instanceof MajorVersionRef) {
				RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> (verResolver, new Integer(((MajorVersionRef)v).getMajorVersion()).toString(), stateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof MaxVersionRef) {
				RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((MaxVersionRef)v).getMaxVersion(), stateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof MinVersionRef) {
				RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((MinVersionRef)v).getMinVersion(), stateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof LowerBoundRangeVersionRef) {
				RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((LowerBoundRangeVersionRef)v).getMinVersion(), ((LowerBoundRangeVersionRef)v).getMaxVersion(), stateResolver, ownerState, v.eResource().getResourceSet());
				injector.injectMembers (stateFilter);
				return stateFilter;
			}
			if (v instanceof FixedVersionRef)
				return new FixedVersionFilter<IEObjectDescription>(verResolver, ((FixedVersionRef) v).getFixedVersion());
		}
		return filter;
	}
	
	protected AbstractPredicateVersionFilter<IEObjectDescription> createVersionFilter(final VersionRef v, EObject owner, List<Service> candidates, ILifecycleStateResolver stateResolver) {
		AbstractPredicateVersionFilter<IEObjectDescription> filter = new NullVersionFilter<IEObjectDescription>();
		if (v != null) {
			IScopeVersionResolver verResolver = new SimpleScopeVersionResolver (v.eResource().getResourceSet());
			if (!stateResolver.definesState(owner)) {
				owner = objLookup.getStatefulOwner(owner);
			}
			LifecycleState ownerState = stateResolver.getLifecycleState(owner);
			
			if (candidates != null && !candidates.isEmpty()) {
				
				CandidateServicesPredicate pred = new CandidateServicesPredicate(candidates, v.eResource().getResourceSet());
				injector.injectMembers(pred);
			
				if (v instanceof MajorVersionRef) {
					RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> (verResolver, new Integer(((MajorVersionRef)v).getMajorVersion()).toString(), stateResolver, ownerState, v.eResource().getResourceSet());
					injector.injectMembers (stateFilter);
					stateFilter.setPreFilterPredicate (pred);
					return stateFilter;
				}
				if (v instanceof MaxVersionRef) {
					RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription> latestMaxExclVersionFilter = new RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((MaxVersionRef)v).getMaxVersion(), stateResolver, ownerState, v.eResource().getResourceSet());
					injector.injectMembers (latestMaxExclVersionFilter);
					latestMaxExclVersionFilter.setPreFilterPredicate(pred);
					return latestMaxExclVersionFilter;
				}
				if (v instanceof MinVersionRef) {
					RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription> latestMinInclVersionFilter = new RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((MinVersionRef)v).getMinVersion(), stateResolver, ownerState, v.eResource().getResourceSet());
					injector.injectMembers (latestMinInclVersionFilter);
					latestMinInclVersionFilter.setPreFilterPredicate(pred);
					return latestMinInclVersionFilter;
				}
				if (v instanceof LowerBoundRangeVersionRef) {
					RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription> latestMinInclMaxExclRangeVersionFilter = new RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription>(verResolver, ((LowerBoundRangeVersionRef)v).getMinVersion(), ((LowerBoundRangeVersionRef)v).getMaxVersion(), stateResolver, ownerState, v.eResource().getResourceSet());
					injector.injectMembers (latestMinInclMaxExclRangeVersionFilter);
					latestMinInclMaxExclRangeVersionFilter.setPreFilterPredicate(pred);
					return latestMinInclMaxExclRangeVersionFilter;
				}
				if (v instanceof FixedVersionRef) {
					FixedVersionFilter<IEObjectDescription> fixedVersionFilter = new FixedVersionFilter<IEObjectDescription>(verResolver, ((FixedVersionRef) v).getFixedVersion());
					fixedVersionFilter.setPreFilterPredicate(pred);
					return fixedVersionFilter;
				}
			} else {
				createVersionFilter(v, owner);
			}
		}
		return filter;
	}
	
	@Override
	protected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {
		List<ImportNormalizer> result = newArrayList();
		result.add(createImportedNamespaceResolver("org.xkonnex.repo.dsl.moduledsl.ext.protocol.*", ignoreCase));
		result.add(createImportedNamespaceResolver("org.xkonnex.repo.dsl.moduledsl.ext.assembly.*", ignoreCase));
		return result;
	}
	
}
