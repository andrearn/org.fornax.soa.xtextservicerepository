/*
 * generated by Xtext
 */
package org.xkonnex.repo.dsl.moduledsl.scoping

import static com.google.common.collect.Lists.newArrayList
import java.util.ArrayList
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.ImportNormalizer
import org.xkonnex.repo.dsl.basedsl.baseDsl.FixedVersionRef
import org.xkonnex.repo.dsl.basedsl.baseDsl.LowerBoundRangeVersionRef
import org.xkonnex.repo.dsl.basedsl.baseDsl.MajorVersionRef
import org.xkonnex.repo.dsl.basedsl.baseDsl.MaxVersionRef
import org.xkonnex.repo.dsl.basedsl.baseDsl.MinVersionRef
import org.xkonnex.repo.dsl.basedsl.baseDsl.VersionRef
import org.xkonnex.repo.dsl.basedsl.scoping.ComponentAwareVersionedScopeProvider
import org.xkonnex.repo.dsl.basedsl.scoping.MapBasedScope
import org.xkonnex.repo.dsl.basedsl.scoping.versions.filter.AbstractPredicateVersionFilter
import org.xkonnex.repo.dsl.basedsl.scoping.versions.filter.FixedVersionFilter
import org.xkonnex.repo.dsl.basedsl.scoping.versions.filter.NullVersionFilter
import org.xkonnex.repo.dsl.basedsl.search.IEObjectLookup
import org.xkonnex.repo.dsl.basedsl.version.IScopeVersionResolver
import org.xkonnex.repo.dsl.basedsl.version.SimpleScopeVersionResolver
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.AbstractResourceRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.AbstractServiceRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ImportServiceRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.Module
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ModuleDslPackage
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ModuleRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.NamespaceRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.OperationRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ProvidingEndpointProtocol
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ServiceModuleRef
import org.xkonnex.repo.dsl.moduledsl.moduleDsl.ServiceRef
import org.xkonnex.repo.dsl.moduledsl.query.IModuleServiceResolver
import org.xkonnex.repo.dsl.moduledsl.query.ModuleLookup
import org.xkonnex.repo.dsl.moduledsl.util.ModuleDslAccess
import org.xkonnex.repo.dsl.profiledsl.profileDsl.LifecycleState
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.ILifecycleStateResolver
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedLatestMajorVersionForOwnerStateFilter
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedLatestMinMaxVersionForOwnerStateFilter
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedLatestMinVersionForOwnerStateFilter
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.RelaxedMaxVersionForOwnerStateFilter
import org.xkonnex.repo.dsl.profiledsl.scoping.versions.StateAttributeLifecycleStateResolver
import org.xkonnex.repo.dsl.servicedsl.service.util.CandidateServicesPredicate
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.Operation
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.Parameter
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.ResourceRef
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.Service
import org.xkonnex.repo.dsl.servicedsl.serviceDsl.ServiceDslPackage
import com.google.common.base.Predicate
import com.google.common.collect.Maps
import com.google.inject.Inject
import com.google.inject.Injector
import org.xkonnex.repo.dsl.servicedsl.service.ModelExtensions

/** 
 * This class contains custom scoping description.
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 */
class ModuleDslScopeProvider extends ComponentAwareVersionedScopeProvider {
	@Inject Injector injector
	@Inject ModuleLookup modLookup
	@Inject IModuleServiceResolver modServiceResolver
	@Inject IQualifiedNameProvider nameProvider
	@Inject ILifecycleStateResolver defaultStateResolver
	@Inject StateAttributeLifecycleStateResolver staticStateResolver
	@Inject IEObjectLookup objLookup
	@Inject extension ModelExtensions

	override IScope getScope(EObject context, EReference reference) {
		if (reference === ModuleDslPackage::Literals::OPERATION_REF__OPERATION) {
			var ServiceRef serviceRef = EcoreUtil2::getContainerOfType(context, typeof(ServiceRef))
			var Map<QualifiedName, EObject> operationsMap = Maps::newHashMap()
			if (serviceRef.getService() !== null) {
				var EList<Operation> operations = serviceRef.getService().getOperations()
				for (Operation operation : operations) {
					operationsMap.put(QualifiedName::create(operation.getName()), operation)
				}
			}
			return new MapBasedScope(operationsMap)
		} else if (reference === ModuleDslPackage::Literals::PARAMETER_REF__PARAMETER) {
			var OperationRef opRef = EcoreUtil2::getContainerOfType(context, typeof(OperationRef))
			var Map<QualifiedName, EObject> parametersMap = Maps::newHashMap()
			if (opRef.getOperation() !== null) {
				var EList<Parameter> parameters = opRef.getOperation().getParameters()
				for (Parameter param : parameters) {
					parametersMap.put(QualifiedName::create(param.getName()), param)
				}
			}
			return new MapBasedScope(parametersMap)
		} else {
			return super.getScope(context, reference)
		}
	}

	override protected AbstractPredicateVersionFilter<IEObjectDescription> getVersionFilterFromContext(EObject context,
		EReference reference) {
		if (reference === ModuleDslPackage::Literals::ABSTRACT_SERVICE_REF__SERVICE && context instanceof ServiceRef) {
			val VersionRef v = ((context as ServiceRef)).getVersionRef()
			if (context.eContainer() instanceof ModuleRef) {
				var AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context,
					staticStateResolver)
				var ModuleRef modRef = (context.eContainer() as ModuleRef)
				var Set<AbstractServiceRef> providedServiceRefs = modServiceResolver.getAllProvidedServiceRefs(
					modRef.getModuleRef().getModule())
				if (!providedServiceRefs.isEmpty()) {
					val List<QualifiedName> provServiceNames = new ArrayList<QualifiedName>()
					for (AbstractServiceRef provSvcRef : providedServiceRefs) {
						provServiceNames.add(nameProvider.getFullyQualifiedName(provSvcRef.getService()))
					}
					createServiceNameFilter(versionFilter, provServiceNames)
				}
				return versionFilter
			} else if (context.eContainer() instanceof NamespaceRef) {
				var AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context,
					staticStateResolver)
				var NamespaceRef nsRef = (context.eContainer() as NamespaceRef)
				var services = nsRef.getNamespace().services
				val List<QualifiedName> provServiceNames = new ArrayList<QualifiedName>()
				for (Service provSvc : services) {
					provServiceNames.add(nameProvider.getFullyQualifiedName(provSvc))
				}
				createServiceNameFilter(versionFilter, provServiceNames)
				return versionFilter
			} else {
				var AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context,
					staticStateResolver)
				return versionFilter
			}
		}
		if (reference === ModuleDslPackage::Literals::ABSTRACT_SERVICE_REF__SERVICE &&
			context instanceof ImportServiceRef) {
			val VersionRef v = ((context as ImportServiceRef)).getVersionRef()
			var ImportServiceRef impSvcRef = (context as ImportServiceRef)
			var Module owningModule = ModuleDslAccess::getOwningModule(impSvcRef)
			val List<ServiceModuleRef> candModules = impSvcRef.getModules()
			var List<Service> candServices = new ArrayList<Service>()
			if (candModules.isEmpty()) {
				var Set<Module> allModules = modLookup.findAllModules(context.eResource().getResourceSet())
				for (Module mod : allModules) {
					if (!mod.equals(owningModule)) {
						extractProvidedServices(context, candServices, mod)
					}
				}
			} else {
				for (ServiceModuleRef ref : candModules) {
					var Module targetModule = ref.getModule()
					// TODO filter modules, that do not have one of the accepted qualifiers
					extractProvidedServices(context, candServices, targetModule)
				}
			}
			if(!candServices.isEmpty() && !candModules.isEmpty()) return createVersionFilter(v, context, candServices,
				staticStateResolver) else return createVersionFilter(v, context, staticStateResolver)
		}
		if (reference === ModuleDslPackage::Literals::SERVICE_MODULE_REF__MODULE &&
			context instanceof ServiceModuleRef) {
			val VersionRef v = ((context as ServiceModuleRef)).getVersion()
			var Module owningModule = ModuleDslAccess::getOwningModule(context)
			return createVersionFilter(v, owningModule, staticStateResolver)
		}
		if (reference === ModuleDslPackage::Literals::ABSTRACT_RESOURCE_REF__RESOURCE &&
			context instanceof AbstractResourceRef) {
			val VersionRef v = ((context as AbstractResourceRef)).getVersionRef()
			var AbstractPredicateVersionFilter<IEObjectDescription> versionFilter = createVersionFilter(v, context,
				staticStateResolver)
			return versionFilter
		}
		return new NullVersionFilter<IEObjectDescription>()
	}

	def private void createServiceNameFilter(AbstractPredicateVersionFilter<IEObjectDescription> versionFilter,
		List<QualifiedName> provServiceNames) {
		versionFilter.setPreFilterPredicate(([IEObjectDescription input|
			for (QualifiedName name : provServiceNames) {
				if (ServiceDslPackage::Literals::SERVICE.equals(input.getEClass()) &&
					input.getQualifiedName() !== null && name !== null && input.getQualifiedName().startsWith(name)) {
					return true
				}
			}
			return false
		] as Predicate<IEObjectDescription>))
	}

	def private void extractProvidedServices(EObject context, List<Service> candServices,
		Module targetModule) {
		var targetModuleVar = targetModule
		if (targetModuleVar !== null) {
			if(targetModuleVar.eIsProxy()) targetModuleVar = EcoreUtil::resolve(targetModuleVar,
				context.eResource().getResourceSet()) as Module
			var Set<AbstractServiceRef> providedServiceRefs = modServiceResolver.getAllProvidedServiceRefs(targetModuleVar)
			for (AbstractServiceRef svcRef : providedServiceRefs) {
				if (svcRef.eIsProxy()) {
					val resolvedSvcRef = EcoreUtil::resolve(svcRef, context.eResource().getResourceSet()) as ServiceRef
					if(resolvedSvcRef.getService() !== null) candServices.add(resolvedSvcRef.getService())
				} else {
					if(svcRef.getService() !== null) candServices.add(svcRef.getService())
				}
			}
		}
	}

	override protected AbstractPredicateVersionFilter<IEObjectDescription> createVersionFilter(VersionRef v,
		EObject owner) {
		var ownerVar = owner
		var AbstractPredicateVersionFilter<IEObjectDescription> filter = new NullVersionFilter<IEObjectDescription>()
		if (v !== null) {
			var IScopeVersionResolver verResolver = new SimpleScopeVersionResolver(v.eResource().getResourceSet())
			if (!staticStateResolver.definesState(ownerVar)) {
				ownerVar = objLookup.getStatefulOwner(ownerVar)
			}
			var LifecycleState ownerState = staticStateResolver.getLifecycleState(ownerVar)
			if (v instanceof MajorVersionRef) {
				var RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, new Integer(((v as MajorVersionRef)).getMajorVersion()).toString(),
					staticStateResolver, ownerState, v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if (v instanceof MaxVersionRef) {
				var RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, ((v as MaxVersionRef)).getMaxVersion(), staticStateResolver, ownerState,
					v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if (v instanceof MinVersionRef) {
				var RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, ((v as MinVersionRef)).getMinVersion(), staticStateResolver, ownerState,
					v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if (v instanceof LowerBoundRangeVersionRef) {
				var RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, ((v as LowerBoundRangeVersionRef)).getMinVersion(),
					((v as LowerBoundRangeVersionRef)).getMaxVersion(), staticStateResolver, ownerState,
					v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if(v instanceof FixedVersionRef) return new FixedVersionFilter<IEObjectDescription>(verResolver,
				((v as FixedVersionRef)).getFixedVersion())
		}
		return filter
	}

	def protected AbstractPredicateVersionFilter<IEObjectDescription> createVersionFilter(VersionRef v,
		EObject owner_finalParam_, ILifecycleStateResolver stateResolver) {
		var owner = owner_finalParam_
		var AbstractPredicateVersionFilter<IEObjectDescription> filter = new NullVersionFilter<IEObjectDescription>()
		if (v !== null) {
			var IScopeVersionResolver verResolver = new SimpleScopeVersionResolver(v.eResource().getResourceSet())
			if (!stateResolver.definesState(owner)) {
				owner = objLookup.getStatefulOwner(owner)
			}
			var LifecycleState ownerState = stateResolver.getLifecycleState(owner)
			if (v instanceof MajorVersionRef) {
				var RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, new Integer(((v as MajorVersionRef)).getMajorVersion()).toString(), stateResolver,
					ownerState, v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if (v instanceof MaxVersionRef) {
				var RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, ((v as MaxVersionRef)).getMaxVersion(), stateResolver, ownerState,
					v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if (v instanceof MinVersionRef) {
				var RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, ((v as MinVersionRef)).getMinVersion(), stateResolver, ownerState,
					v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if (v instanceof LowerBoundRangeVersionRef) {
				var RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription>(
					verResolver, ((v as LowerBoundRangeVersionRef)).getMinVersion(),
					((v as LowerBoundRangeVersionRef)).getMaxVersion(), stateResolver, ownerState,
					v.eResource().getResourceSet())
				injector.injectMembers(stateFilter)
				return stateFilter
			}
			if(v instanceof FixedVersionRef) return new FixedVersionFilter<IEObjectDescription>(verResolver,
				((v as FixedVersionRef)).getFixedVersion())
		}
		return filter
	}

	def protected AbstractPredicateVersionFilter<IEObjectDescription> createVersionFilter(VersionRef v,
		EObject owner_finalParam_, List<Service> candidates, ILifecycleStateResolver stateResolver) {
		var owner = owner_finalParam_
		var AbstractPredicateVersionFilter<IEObjectDescription> filter = new NullVersionFilter<IEObjectDescription>()
		if (v !== null) {
			var IScopeVersionResolver verResolver = new SimpleScopeVersionResolver(v.eResource().getResourceSet())
			if (!stateResolver.definesState(owner)) {
				owner = objLookup.getStatefulOwner(owner)
			}
			var LifecycleState ownerState = stateResolver.getLifecycleState(owner)
			if (candidates !== null && !candidates.isEmpty()) {
				var CandidateServicesPredicate pred = new CandidateServicesPredicate(candidates,
					v.eResource().getResourceSet())
				injector.injectMembers(pred)
				if (v instanceof MajorVersionRef) {
					var RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription> stateFilter = new RelaxedLatestMajorVersionForOwnerStateFilter<IEObjectDescription>(
						verResolver, new Integer(((v as MajorVersionRef)).getMajorVersion()).toString(), stateResolver,
						ownerState, v.eResource().getResourceSet())
					injector.injectMembers(stateFilter)
					stateFilter.setPreFilterPredicate(pred)
					return stateFilter
				}
				if (v instanceof MaxVersionRef) {
					var RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription> latestMaxExclVersionFilter = new RelaxedMaxVersionForOwnerStateFilter<IEObjectDescription>(
						verResolver, ((v as MaxVersionRef)).getMaxVersion(), stateResolver, ownerState,
						v.eResource().getResourceSet())
					injector.injectMembers(latestMaxExclVersionFilter)
					latestMaxExclVersionFilter.setPreFilterPredicate(pred)
					return latestMaxExclVersionFilter
				}
				if (v instanceof MinVersionRef) {
					var RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription> latestMinInclVersionFilter = new RelaxedLatestMinVersionForOwnerStateFilter<IEObjectDescription>(
						verResolver, ((v as MinVersionRef)).getMinVersion(), stateResolver, ownerState,
						v.eResource().getResourceSet())
					injector.injectMembers(latestMinInclVersionFilter)
					latestMinInclVersionFilter.setPreFilterPredicate(pred)
					return latestMinInclVersionFilter
				}
				if (v instanceof LowerBoundRangeVersionRef) {
					var RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription> latestMinInclMaxExclRangeVersionFilter = new RelaxedLatestMinMaxVersionForOwnerStateFilter<IEObjectDescription>(
						verResolver, ((v as LowerBoundRangeVersionRef)).getMinVersion(),
						((v as LowerBoundRangeVersionRef)).getMaxVersion(), stateResolver, ownerState,
						v.eResource().getResourceSet())
					injector.injectMembers(latestMinInclMaxExclRangeVersionFilter)
					latestMinInclMaxExclRangeVersionFilter.setPreFilterPredicate(pred)
					return latestMinInclMaxExclRangeVersionFilter
				}
				if (v instanceof FixedVersionRef) {
					var FixedVersionFilter<IEObjectDescription> fixedVersionFilter = new FixedVersionFilter<IEObjectDescription>(
						verResolver, ((v as FixedVersionRef)).getFixedVersion())
					fixedVersionFilter.setPreFilterPredicate(pred)
					return fixedVersionFilter
				}
			} else {
				createVersionFilter(v, owner)
			}
		}
		return filter
	}

	override protected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {
		var List<ImportNormalizer> result = newArrayList()
		result.add(createImportedNamespaceResolver("org.xkonnex.repo.dsl.moduledsl.ext.protocol.*", ignoreCase))
		result.add(createImportedNamespaceResolver("org.xkonnex.repo.dsl.moduledsl.ext.assembly.*", ignoreCase))
		result.add(createImportedNamespaceResolver("org.xkonnex.repo.dsl.servicedsl.serviceDsl.Verb", ignoreCase))
		return result
	}
}
