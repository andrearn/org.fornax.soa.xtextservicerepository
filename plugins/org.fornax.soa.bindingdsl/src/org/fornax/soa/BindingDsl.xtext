/*
Copyright (c) 2010-2011 André Arnold and others.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
    André Arnold 		- initial API and implementation
    Vitaly Markin		- reviews
*/
grammar org.fornax.soa.BindingDsl with org.fornax.soa.basedsl.SOABaseDsl

generate bindingDsl "http://www.fornax.org/soa/BindingDsl"

import "platform:/resource/org.fornax.soa.servicedsl/src-gen/org/fornax/soa/ServiceDsl.ecore" as serviceDsl
import "platform:/resource/org.fornax.soa.moduledsl/src-gen/org/fornax/soa/moduledsl/ModuleDsl.ecore" as moduleDsl
import "platform:/resource/org.fornax.soa.environmentdsl/src-gen/org/fornax/soa/EnvironmentDsl.ecore" as environmentDsl
import "platform:/resource/org.fornax.soa.profiledsl/src-gen/org/fornax/soa/profiledsl/SOAProfileDsl.ecore" as profileDsl
import "platform:/resource/org.fornax.soa.sladsl/src-gen/org/fornax/soa/SLADsl.ecore" as slaDsl

BindingModel:
	(imports+=Import)*
	(bindings+=Binding)*;


Binding: DomainBinding | ModuleBinding | ServiceBinding ;

/*
 * Binds all services in the given namespace, where the service lifecycle state matches the minimal required lifecycle state of the 
 * targeted environment
 */
DomainBinding: 
	'bind namespace' subNamespace=[serviceDsl::SubNamespace|QualifiedName] 'as' name=QualifiedName 'to' 'environment' environment=[environmentDsl::Environment] '{'
		(qualifier=Qualifier)?
		('protocols' '{'
			(protocol+=BindingProtocol)+
		'}')?
		('policies' '{'
			(policies+=Policy)*
		'}')?
		('provider-policies' '{'
			(providerPolicies+=Policy)*
		'}')?
		('SLAs' (sla+=[slaDsl::SLA|QualifiedName]) (',' sla+=[slaDsl::SLA|QualifiedName])* )?
		(serviceBinding+=ServiceBinding)*
		(components+=Component)*
	'}';
	
Publisher:
	'publish on' pubServer=[environmentDsl::Server|QualifiedName] ('with' 'connector' (connectors+=[environmentDsl::Connector | QualifiedName]) (',' connectors+=[environmentDsl::Connector | QualifiedName])*)?;
	
Provider:
	'provided on' provServer = [environmentDsl::Server|QualifiedName] ('with' 'connector' (connectors+=[environmentDsl::Connector | QualifiedName]) (',' connectors+=[environmentDsl::Connector | QualifiedName])*)?;

/*
 * Overrides the binding of a parent DomainBinding or ModuleBinding for the given Service
 */
ServiceBinding:
	'bind-service' service=ServiceRef '{'
		(qualifier=Qualifier)?
		'protocols' '{'
			(protocol+=BindingProtocol)+
		'}'
		('policies' '{'
			(policies+=Policy)*
		'}')?
		('SLAs' (sla+=[slaDsl::SLA|QualifiedName])(',' sla+=[slaDsl::SLA|QualifiedName])* )?
		('references-module' referencedModule = ModuleRef)?
		(operation+=OperationBinding)*
	'}';

/*
 * References a service constained by the VersionRef constraint
 */	
ServiceRef:
	service=[serviceDsl::Service|QualifiedName] versionRef=VersionRef;
	

/*
 * The endpoint protocol of the entpoint on which the service is provided
 */	
BindingProtocol: SCA | SOAP | EJB | HTTP | REST | SAP | JMS | FILE | FTP;

/*
 * Overrides the binding of a parent ServiceBinding for the given service Operation
 */
OperationBinding: 
	'bind-operation' operation=[serviceDsl::Operation|QualifiedName] '{' 
		(qualifier=Qualifier)?
		'protocols' '{'
			(protocol+=BindingProtocol)+
		'}'
		('provider-protocols' '{'
			(providerProtocol+=BindingProtocol)+
		'}')?
		('policies' '{'
			(policies+=Policy)*
		'}')?
		('provider-policies' '{'
			(providerPolicies+=Policy)*
		'}')?
		('SLAs' (sla+=[slaDsl::SLA|QualifiedName]) (',' sla+=[slaDsl::SLA|QualifiedName])* )?
	'}';

/*
 * Binds the referenced module to the given target environment. All services provided by the module become available in the
 * targeted environment
 */	
ModuleBinding:
	'bind-module' module=ModuleRef 'as' name=QualifiedName 'to' 'environment' environment=[environmentDsl::Environment|QualifiedName] '{'
		(qualifier=Qualifier)?
		/* The server to bind the endpoint to */
		provider=Provider
		/* The default endpoint protocols to be used by default. The protocols respective connector on the server is used to expose the service */
		('default-protocols' '{'
			(protocol+=BindingProtocol)+
		'}')?
		
		('default-policies' '{'
			(policies+=Policy)*
		'}')?
		('default-SLAs' (sla+=[slaDsl::SLA|QualifiedName]) (',' sla+=[slaDsl::SLA|QualifiedName])* )?
		(serviceBindings+=ServiceBinding)*
	'}'
;

ModuleRef: module=[moduleDsl::Module|QualifiedName] versionRef=VersionRef;

Component:
	'component' name=ID 'implements' implements=ServiceRef '{'
		'bind to environment' environment = [environmentDsl::Environment|QualifiedName]
		(qualifier=Qualifier)?
		'provided-services' services+=ServiceRef (',' services+=ServiceRef)* 
		('referenced-services' referencedServices+=ServiceRef (',' )* )?
		'protocols' '{'
			(protocol+=BindingProtocol)+
		'}'
		(operation+=OperationBinding)*
		('policies' '{'
			(policies+=Policy)*
		'}')?
		('provider-policies' '{'
			(providerPolicies+=Policy)*
		'}')?
		('SLAs' (sla+=[slaDsl::SLA|QualifiedName]) (',' sla+=[slaDsl::SLA|QualifiedName])* )?
		'implementation' implementation=ImplementationType 
		('sourceURL' source=STRING )? //Where can I get the sources?
	'}';

enum ImplementationType: BPMN | BPMN2 | BPEL | WSHT='WS-HT' | RuleML | Drools | Mediation | Java | CS='C#' | CPP='C++' | Scala | Ruby | PHP | WSDocLit = 'WS-Document/Literal' | WSRPC = 'WS-RPC/Literal' | WSRPCEnc='WS-RPC/Encoded' | REST_XML='REST-XML' | REST_JSON = 'REST-JSON'| EJB | Spring | EJB2 | SAP | SAP_IDOC = 'SAP/iDoc' | SAP_BAPI = 'SAP/BAPI'| Corba | Shell | Siebel | Tuxedo | File | SQL | Ivy | jPDL3 | jPDL4;

/* Use SOAP on the endpoint */
SOAP: 
	'SOAP' '{'
		{SOAP}
		(qualifier=Qualifier)?
		(publisher=Publisher)?
		(provider=Provider)?
		('style' style=SOAPStyle )?
		('http-context-root' contextRoot = STRING )?
		('provider-http-context-root' providerContextRoot = STRING )?
		('provided-WSDL-Url' providedWsdlUrl = STRING )?
	'}';
	
enum SOAPStyle: doclitwrap='document/literal-wrapped' | rpclit = 'rpc/literal' | rpcenc='rpc/encoded';

/* SAP endpoint (RFC or IDoc as stated with the SAPTransport */
SAP: 
	'SAP' '{'
		{SAP}
		(qualifier=Qualifier)?
		(provider=Provider)?
		('transport' transport=SAPTransport )?
		('client' client=[environmentDsl::SapClient|QualifiedName] )?
	'}';

enum SAPTransport: IDOC | RFC;

/* An EJB endpoint protocol (IIOP/RMI) */ 
EJB: 
	'EJB' '{'
		(qualifier=Qualifier)?
		(publisher=Publisher)?
		(provider=Provider)?
		'jndi-name' jndiName=STRING 
	'}';

/* A  plain HTTP endpoint protocol */	
HTTP: 
	'HTTP' '{'
		(qualifier=Qualifier)?
		(publisher=Publisher)?
		(provider=Provider)?
		'url' url=STRING 
		'provider-url' providerUrl=STRING  
		'verb' verb=Verb 
	'}';

/* A REST endpoint protocol */
REST: 
	'REST' '{'
		(qualifier=Qualifier)?
		(publisher=Publisher)?
		(provider=Provider)?
		'path' path=STRING  
		'provider-url' providerUrl=STRING  
		'verb' verb=Verb 
		('format' format=RESTFormat)? 
		('consumes-format' consumesFormat=RESTFormat)? 
		('provides-format' provideFormat=RESTFormat)? 
	'}';

/* The wire data serialization format */	
enum RESTFormat: JSON | XML | BISON | OTHER;
/* The REST operation verb */
enum Verb: CREATE | RETRIEVE | UPDATE | DELETE | GET | PUT | POST;

/* A JMS endpoint protocol. The actual wire format of the messages is not specified. However, the Broker exposes an JMS API */
JMS:
	'JMS' '{'
		{JMS}
		(qualifier=Qualifier)?
		(publisher=Publisher)?
		(provider=Provider)?
		(channel=TopicOrQueue)?
		'jndi-name' jndiName=STRING
		('provider-jndi-name' providerJndi=STRING )?
	'}';
	
TopicOrQueue: Topic | Queue;

/* JMS topic to send/retrieve messages */
Topic: 'topic' name=STRING (qualifier=Qualifier)?;

/* JMS queue to send/retrieve messages */
Queue: 'queue' name=STRING (qualifier=Qualifier)?;

/* An SCA native endpoint protocol. Messages are accessed via the SCA API or import/export primitives*/	
SCA:
	{SCA} 
	'SCA' (name=STRING)? '{'
		(qualifier=Qualifier)?
		(publisher=Publisher)?
		(provider=Provider)?
		('promote' promote=STRING )?
		('reference' reference=STRING (isMultipleRef?='[]')? )?
	'}' ;

/* A file access protocol for endpoints */
FILE: 
	'FILE' '{'
		(qualifier=Qualifier)?
		url=STRING accessType=ReadWrite ('interval' pollIntervall=STRING)?
	'}';

/* Use FTP to access message files on the endpoint */
FTP: 
	'FTP' '{' 
		(qualifier=Qualifier)?
		'access' accessType=ReadWrite ('interval' pollIntervall=STRING)?
	'}';

enum ReadWrite : read|write;

/* Service policies */
Policy: LogPolicy | SecurityPolicy;

/* Logging policy to be applied to the services */
LogPolicy: 'logging policy' logPolicy=LogPolicyKind ;

/* Security policy to be applied to the services */
SecurityPolicy : AuthenticationPolicy | AuthorizationPolicy | SigningPolicy | EncryptionPolicy;

/* Policy, that defines how consumer are authenticated */
AuthenticationPolicy : 
	{AuthenticationPolicy}
	'authn policy' (name=ID)? (optional?='optional')? '{'
		'auth tokens' '{'
			(authTokens+=AuthToken)+
		'}'
		'hash algorithms' '{'
			(hashAlgorithms+=HashAlgorithm)*
		'}'
	'}';
	
AuthToken : (optional?='optional')? kind=AuthTokenKind ;

HashAlgorithm : (optional?='optional')? (useBase64?="Base64-encoded")? kind=HashAlgKind ;

enum HashAlgKind : MD5 | SHA1 | SHA256 | PlainText;

/* Policy, that defines, how service consumers are authorized*/
AuthorizationPolicy : {AuthorizationPolicy} 'authorization rolicy';

/* How messages are signed, to verify their authenticity */
SigningPolicy : {SigningPolicy} 'signing policy';

/* How messages are encrypted */
EncryptionPolicy : {EncryptionPolicy} 'encryption policy';

enum AuthTokenKind: UsernamePassword | SAML | SAML2 | Kerberos;

enum LogPolicyKind: NONE | HEADER | ALL;
